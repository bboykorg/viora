<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Путь Жизни — Viora</title>
    <style>
        /* Все стили остаются как были */
        :root {
            --panel-bg: rgba(8,8,10,0.6);
            --accent: #7dd3fc;
            --neon: rgba(0,217,255,0.70);
            --bg-dark: #09090b;
            --glass-bg: rgba(10,10,15,0.45);
            --glass-border: rgba(255,255,255,0.08);
            --text-primary: #fff;
            --text-muted: rgba(255,255,255,0.6);
            --pro-color: #10b981;
            --con-color: #ef4444;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            margin: 0;
            font-family: Inter, Arial, sans-serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            touch-action: none;
        }

        .editor-page {
            width: 100vw;
            height: 100vh;
            display: flex;
            gap: 10px;
            padding: 10px;
            box-sizing: border-box;
            align-items: stretch;
            position: relative;
            overflow: hidden;
        }

        .canvas-area {
            flex: 1 1 auto;
            border-radius: 12px;
            background: var(--glass-bg);
            backdrop-filter: blur(6px);
            position: relative;
            overflow: auto;
            padding: 20px;
            min-width: max-content;
            min-height: max-content;
            touch-action: pan-x pan-y;
            -webkit-overflow-scrolling: touch;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: var(--bg-dark);
        }

        .canvas-transform {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform-origin: 0 0;
            transition: transform 0.1s ease-out;
        }

        .canvas-content {
            position: absolute;
            top: 0;
            left: 0;
            width: 5000px;
            height: 5000px;
            background: var(--bg-dark);
        }

        .canvas-pan-cursor { cursor: grab; }
        .canvas-panning { cursor: grabbing !important; }
        .canvas-zooming { cursor: zoom-in; }

        .side-panel {
            position: absolute;
            right: 10px;
            top: 10px;
            width: 320px;
            max-width: 90vw;
            height: calc(100vh - 40px);
            max-height: 70vh;
            background: var(--panel-bg);
            border-radius: 10px;
            padding: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.6);
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
            z-index: 1000;
            touch-action: none;
        }

        .side-panel.hidden {
            display: none;
        }

        .open-panel-btn {
            position: fixed;
            top: 50px;
            right: 10px;
            background: var(--accent);
            color: #0a0a0f;
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            z-index: 999;
            display: none;
        }

        .open-panel-btn.visible {
            display: block;
        }

        .side-header {
            cursor: grab;
            user-select: none;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px;
            border-bottom: 1px solid rgba(255,255,255,0.04);
            margin-bottom: 8px;
            border-radius: 6px;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .side-title {
            font-weight: 700;
            font-size: 16px;
        }

        .side-sub {
            font-size: 12px;
            color: var(--text-muted);
            display: none;
        }

        .panel-left-handle {
            position: absolute;
            left: -8px;
            top: 8px;
            bottom: 8px;
            width: 12px;
            cursor: ew-resize;
            border-radius: 6px;
            background: rgba(255,255,255,0.1);
            display: none;
        }

        .node {
            width: 90vw;
            max-width: 280px;
            min-height: 60px;
            background: rgba(255,255,255,0.03);
            border: 1px solid var(--glass-border);
            border-radius: 15px;
            padding: 10px;
            position: absolute;
            display: flex;
            flex-direction: column;
            gap: 6px;
            cursor: move;
            z-index: 10;
            transition: transform 0.2s ease;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            touch-action: none;
        }

        .node:active {
            cursor: grabbing;
            z-index: 1000;
        }

        .node:hover {
            transform: scale(1.02);
        }

        .node .title {
            font-weight: 600;
            font-size: 14px;
            color: var(--text-primary);
            outline: none;
            min-height: 20px;
            background: transparent;
            border: none;
            width: 100%;
            cursor: text;
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            user-select: text;
            padding: 2px;
        }

        .title[contenteditable]:empty:before {
            content: attr(data-placeholder);
            color: rgba(255,255,255,0.35);
            display: block;
        }

        .controls {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-top: 6px;
        }

        .buttons-container {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .add-btn, .remove-btn, .toggle-btn {
            width: 32px;
            height: 32px;
            min-width: 32px;
            min-height: 32px;
            border-radius: 8px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            background: rgba(255,255,255,0.04);
            border: 1px solid rgba(255,255,255,0.06);
            color: var(--text-primary);
            cursor: pointer;
            user-select: none;
            transition: all 0.2s ease;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            touch-action: manipulation;
            font-size: 16px;
        }

        .add-btn {
            font-weight: 700;
        }

        .add-btn:hover {
            background: rgba(0,217,255,0.2);
            border-color: rgba(0,217,255,0.4);
        }

        .remove-btn:hover {
            background: rgba(255,68,68,0.2);
            border-color: rgba(239,68,68,0.4);
        }

        .toggle-btn:hover {
            background: rgba(0,217,255,0.2);
            border-color: rgba(0,217,255,0.4);
        }

        .small-muted {
            color: var(--text-muted);
            font-size: 12px;
        }

        .connector-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .connector-svg path {
            stroke: var(--neon) !important;
            stroke-width: 3 !important;
            stroke-linecap: round;
            stroke-linejoin: round;
            fill: none;
            opacity: 0.98;
            filter: drop-shadow(0 0 6px rgba(0,217,255,0.25));
        }

        .ai-box {
            background: rgba(255,255,255,0.02);
            padding: 10px;
            border-radius: 8px;
            min-height: 100px;
            overflow: auto;
            max-height: 40vh;
            font-size: 14px;
            line-height: 1.4;
            -webkit-overflow-scrolling: touch;
        }

        .ai-box .ai-response {
            margin-bottom: 10px;
            padding: 8px;
            background: rgba(255,255,255,0.02);
            border-radius: 6px;
            border: 1px solid rgba(255,255,255,0.04);
        }

        .ai-box .ai-response .meta {
            font-size: 12px;
            color: rgba(255,255,255,0.85);
        }

        .ai-box .ai-response pre {
            white-space: pre-wrap;
            word-break: break-word;
            margin: 6px 0 0 0;
            font-family: inherit;
            font-size: 12px;
        }

        .action-row {
            display: flex;
            gap: 8px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .button-primary, .button-ghost, .button-danger {
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
            font-size: 14px;
            touch-action: manipulation;
            min-height: 44px;
            min-width: 44px;
            flex: 1;
        }

        .button-primary {
            background: var(--accent);
            color: #0a0a0f;
        }

        .button-primary:hover {
            box-shadow: 0 0 12px rgba(0,217,255,0.5);
        }

        .button-ghost {
            background: transparent;
            color: var(--text-primary);
            border: 1px solid rgba(255,255,255,0.08);
        }

        .button-ghost:hover {
            background: rgba(255,255,255,0.05);
        }

        .button-danger {
            background: rgba(239,68,68,0.1);
            color: #ef4444;
            border: 1px solid rgba(239,68,68,0.2);
        }

        .button-danger:hover {
            background: rgba(239,68,68,0.2);
        }

        .result-highlight {
            border-left: 3px solid var(--accent);
            padding-left: 6px;
            margin-bottom: 6px;
        }

        .back-link {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 1100;
            background: rgba(255,255,255,0.06);
            color: var(--text-primary);
            text-decoration: none;
            display: inline-flex;
            gap: 6px;
            padding: 8px 10px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.08);
            font-weight: 600;
            transition: all 0.2s ease;
            touch-action: manipulation;
            min-height: 40px;
            min-width: 40px;
            align-items: center;
            font-size: 14px;
        }

        .back-link:hover {
            background: rgba(0,217,255,0.15);
            border-color: rgba(0,217,255,0.4);
        }

        .node[data-type="pro"] {
            border-left: 4px solid rgba(16,185,129,0.3);
            background: rgba(16,185,129,0.05);
        }

        .node[data-type="con"] {
            border-left: 4px solid rgba(239,68,68,0.3);
            background: rgba(239,68,68,0.05);
        }

        .node[data-type="pros-container"] {
            border-left: 4px solid rgba(16,185,129,0.5);
            background: rgba(16,185,129,0.08);
            font-weight: 700;
            font-size: 14px;
            color: var(--pro-color);
        }

        .node[data-type="cons-container"] {
            border-left: 4px solid rgba(239,68,68,0.5);
            background: rgba(239,68,68,0.08);
            font-weight: 700;
            font-size: 14px;
            color: var(--con-color);
        }

        /* Показываем кнопки сворачивания для контейнеров */
        .node[data-type="pros-container"] .buttons-container,
        .node[data-type="cons-container"] .buttons-container {
            display: flex;
        }

        .node[data-type="pros-container"] .title,
        .node[data-type="cons-container"] .title {
            cursor: default;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        /* Скрытые узлы */
        .node.hidden {
            display: none;
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            backdrop-filter: blur(4px);
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-content {
            background: var(--panel-bg);
            border-radius: 10px;
            padding: 15px;
            max-width: 90vw;
            width: 300px;
            box-shadow: 0 15px 40px rgba(0,0,0,0.8);
            border: 1px solid var(--glass-border);
        }

        .modal-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 10px;
            color: var(--text-primary);
        }

        .modal-text {
            color: var(--text-muted);
            margin-bottom: 15px;
            line-height: 1.4;
            font-size: 14px;
        }

        .modal-actions {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
            flex-wrap: wrap;
        }

        .modal-button {
            padding: 8px 12px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
            touch-action: manipulation;
            min-height: 40px;
            min-width: 60px;
            flex: 1;
        }

        .modal-button.cancel {
            background: rgba(255,255,255,0.05);
            color: var(--text-primary);
            border: 1px solid var(--glass-border);
        }

        .modal-button.confirm {
            background: var(--accent);
            color: #0a0a0f;
        }

        /* НОВЫЕ СТИЛИ ДЛЯ КОНТРОЛОВ МАСШТАБА */
        .zoom-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 8px;
            background: var(--panel-bg);
            border-radius: 8px;
            padding: 8px;
            border: 1px solid var(--glass-border);
        }

        .zoom-btn {
            width: 40px;
            height: 40px;
            background: rgba(255,255,255,0.05);
            border: 1px solid var(--glass-border);
            color: var(--text-primary);
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            transition: all 0.2s ease;
        }

        .zoom-btn:hover {
            background: rgba(0,217,255,0.2);
            border-color: rgba(0,217,255,0.4);
        }

        .zoom-display {
            text-align: center;
            font-size: 12px;
            color: var(--text-muted);
            margin-top: 4px;
        }

        @media (max-width: 768px) {
            .editor-page {
                flex-direction: column;
                padding: 5px;
                gap: 5px;
            }

            .canvas-area {
                padding: 15px;
                min-height: 60vh;
                border-radius: 10px;
            }

            .side-panel {
                position: relative;
                width: 100%;
                max-width: 100%;
                height: auto;
                max-height: 50vh;
                right: auto;
                top: auto;
                margin-top: 5px;
                padding: 8px;
            }

            .side-header {
                padding: 6px;
            }

            .node {
                width: 90vw;
                max-width: 260px;
                padding: 8px;
                min-height: 50px;
                border-radius: 12px;
            }

            .node .title {
                font-size: 13px;
                min-height: 18px;
            }

            .controls {
                margin-top: 4px;
            }

            .buttons-container {
                gap: 4px;
            }

            .add-btn, .remove-btn, .toggle-btn {
                width: 28px;
                height: 28px;
                min-width: 28px;
                min-height: 28px;
                font-size: 14px;
            }

            .small-muted {
                font-size: 11px;
            }

            .ai-box {
                padding: 8px;
                max-height: 35vh;
                font-size: 12px;
            }

            .ai-box .ai-response {
                padding: 6px;
            }

            .ai-box .ai-response .meta {
                font-size: 11px;
            }

            .ai-box .ai-response pre {
                font-size: 11px;
            }

            .action-row {
                flex-direction: column;
                gap: 6px;
            }

            .button-primary, .button-ghost, .button-danger {
                width: 100%;
                min-height: 40px;
                font-size: 12px;
            }

            .back-link {
                top: 5px;
                left: 5px;
                min-height: 36px;
                min-width: 36px;
                padding: 6px 8px;
                font-size: 12px;
            }

            .panel-left-handle {
                display: none;
            }

            .open-panel-btn {
                top: 40px;
            }

            .zoom-controls {
                bottom: 10px;
                right: 10px;
            }

            .zoom-btn {
                width: 36px;
                height: 36px;
                font-size: 16px;
            }
        }

        @media (max-width: 480px) {
            .editor-page {
                padding: 5px;
                gap: 5px;
            }

            .canvas-area {
                padding: 10px;
                border-radius: 8px;
            }

            .side-panel {
                padding: 6px;
                max-height: 45vh;
            }

            .side-header {
                padding: 4px;
            }

            .node {
                width: 92vw;
                max-width: 240px;
                padding: 6px;
                min-height: 45px;
                border-radius: 10px;
            }

            .node .title {
                font-size: 12px;
                min-height: 16px;
            }

            .controls {
                margin-top: 3px;
            }

            .buttons-container {
                gap: 3px;
            }

            .add-btn, .remove-btn, .toggle-btn {
                width: 24px;
                height: 24px;
                min-width: 24px;
                min-height: 24px;
                font-size: 12px;
            }

            .small-muted {
                font-size: 10px;
            }

            .ai-box {
                padding: 6px;
                max-height: 30vh;
                font-size: 11px;
            }

            .ai-box .ai-response {
                padding: 4px;
            }

            .ai-box .ai-response .meta {
                font-size: 10px;
            }

            .ai-box .ai-response pre {
                font-size: 10px;
            }

            .action-row {
                gap: 4px;
            }

            .button-primary, .button-ghost, .button-danger {
                min-height: 36px;
                font-size: 11px;
            }

            .back-link {
                top: 5px;
                left: 5px;
                min-height: 32px;
                min-width: 32px;
                padding: 4px 6px;
                font-size: 10px;
            }

            .modal-content {
                width: 90vw;
                padding: 8px;
            }

            .modal-title {
                font-size: 13px;
                margin-bottom: 6px;
            }

            .modal-text {
                font-size: 11px;
                margin-bottom: 8px;
            }

            .modal-actions {
                gap: 6px;
            }

            .modal-button {
                padding: 6px 10px;
                min-height: 34px;
                font-size: 11px;
            }

            .zoom-controls {
                bottom: 5px;
                right: 5px;
            }

            .zoom-btn {
                width: 32px;
                height: 32px;
                font-size: 14px;
            }
        }

        .no-select {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        .pros-list, .cons-list {
            margin: 8px 0;
            padding-left: 16px;
        }

        .pros-list li, .cons-list li {
            margin: 4px 0;
            font-size: 12px;
            line-height: 1.3;
        }

        .pros-list {
            color: var(--pro-color);
        }

        .cons-list {
            color: var(--con-color);
        }

        .node[data-type="pros-container"] .add-btn,
        .node[data-type="cons-container"] .add-btn {
            display: none !important;
        }
    </style>
</head>
<body class="no-select">
    <a class="back-link" href="/">← Назад</a>

    <button class="open-panel-btn" id="openPanelBtn">Открыть ИИ</button>

    <div class="zoom-controls">
        <button class="zoom-btn" id="zoomIn" title="Увеличить">+</button>
        <button class="zoom-btn" id="zoomOut" title="Уменьшить">−</button>
        <button class="zoom-btn" id="resetZoom" title="Сбросить масштаб">↺</button>
        <div class="zoom-display" id="zoomLevel">100%</div>
    </div>

    <div class="editor-page" id="editorPage">
        <div class="canvas-area canvas-pan-cursor" id="canvasArea">
            <div class="canvas-container" id="canvasContainer">
                <div class="canvas-transform" id="canvasTransform">
                    <div class="canvas-content" id="canvasContent">
                        <svg class="connector-svg" id="connectors"></svg>

                        <div class="node" id="node-root" style="left: calc(50% - 110px); top: 80px;" data-id="root">
                            <div contenteditable class="title" data-placeholder="Опишите проблему...">Нажмите и впишите проблему</div>
                            <div class="controls">
                                <div class="small-muted">Главный пункт</div>
                                <div class="buttons-container">
                                    <div class="add-btn" title="Добавить исход" data-add>+</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="side-panel" id="sidePanel" role="region" aria-label="ИИ-панель">
            <div class="panel-left-handle" id="panelHandle" title="Перетащите чтобы изменить ширину"></div>
            <div class="side-header" id="sideHeader">
                <div>
                    <div class="side-title">ИИ-помощник</div>
                    <div class="side-sub">Перетащите заголовок чтобы переместить панель; потяните слева чтобы изменить ширину.</div>
                </div>
                <div style="display:flex;gap:8px;align-items:center">
                    <button id="panelCollapseBtn" class="button-ghost" title="Свернуть/развернуть">↔</button>
                    <button id="panelCloseBtn" class="button-ghost" title="Скрыть панель">✕</button>
                </div>
            </div>

            <div style="font-weight:600">Заголовок (проблема)</div>
            <div id="ai-title" class="small-muted" style="min-height:34px">—</div>

            <div style="height:10px"></div>
            <div style="font-weight:600">Исходы (варианты решения)</div>
            <div id="ai-outcomes" class="small-muted" style="min-height:60px">—</div>

            <div style="height:12px"></div>
            <div class="ai-box" id="ai-output">Нажмите «Предложить», чтобы ИИ проанализировал варианты.</div>

            <div class="action-row" style="margin-top:12px">
                <button class="button-primary" id="ai-run">Предложить</button>
                <button class="button-danger" id="ai-reset">Сбросить ответы</button>
            </div>

            <div style="height:8px"></div>
            <div class="small-muted">Таймер блокировки: <span id="ai-timer">—</span></div>
        </div>
    </div>

    <div class="modal-overlay" id="modalOverlay">
        <div class="modal-content">
            <div class="modal-title" id="modalTitle">Подтверждение</div>
            <div class="modal-text" id="modalText">Вы уверены, что хотите выполнить это действие?</div>
            <div class="modal-actions">
                <button class="modal-button cancel" id="modalCancel">Отмена</button>
                <button class="modal-button confirm" id="modalConfirm">ОК</button>
            </div>
        </div>
    </div>

<script>
// ========== КОНФИГУРАЦИЯ ==========
const STORAGE_KEY = 'viora_state_v3';
const canvas = document.getElementById('canvasArea');
const canvasContainer = document.getElementById('canvasContainer');
const canvasTransform = document.getElementById('canvasTransform');
const canvasContent = document.getElementById('canvasContent');
const connectorsSvg = document.getElementById('connectors');
const sidePanel = document.getElementById('sidePanel');
const panelHandle = document.getElementById('panelHandle');
const sideHeader = document.getElementById('sideHeader');
const panelCollapseBtn = document.getElementById('panelCollapseBtn');
const panelCloseBtn = document.getElementById('panelCloseBtn');
const openPanelBtn = document.getElementById('openPanelBtn');
const modalOverlay = document.getElementById('modalOverlay');
const modalTitle = document.getElementById('modalTitle');
const modalText = document.getElementById('modalText');
const modalCancel = document.getElementById('modalCancel');
const modalConfirm = document.getElementById('modalConfirm');

// ЭЛЕМЕНТЫ МАСШТАБА
const zoomInBtn = document.getElementById('zoomIn');
const zoomOutBtn = document.getElementById('zoomOut');
const resetZoomBtn = document.getElementById('resetZoom');
const zoomLevelDisplay = document.getElementById('zoomLevel');

let edges = [];
let nodeCounter = 1;
const MAX_RETRIES = 4;
let isLockedUntil = 0;
let timerInterval = null;
let _saveTimeout = null;
let modalResolve = null;

// ПЕРЕМЕННЫЕ ДЛЯ МАСШТАБИРОВАНИЯ И ПАННОРАМИРОВАНИЯ
let scale = 1;
let translateX = 0;
let translateY = 0;
let isPanning = false;
let panStart = { x: 0, y: 0 };
let startTranslate = { x: 0, y: 0 };

// КОНФИГУРАЦИЯ МАСШТАБА
const ZOOM_CONFIG = {
    min: 0.1,
    max: 3.0,
    step: 0.1,
    default: 1.0
};

// КОНФИГУРАЦИЯ РАСПОЛОЖЕНИЯ И ГРАНИЦ
const LAYOUT_CONFIG = {
  NODE_WIDTH: 280,
  NODE_HEIGHT: 80,
  COLUMN_SPACING: 400,
  ROW_SPACING: 150,
  HORIZONTAL_OFFSET: 350,
  PRO_CON_SPACING: 25,
  CANVAS_WIDTH: 5000,
  CANVAS_HEIGHT: 5000
};

// Границы перемещения блоков (уменьшены для комфортной работы)
const BOUNDARIES = {
  minX: 50,
  minY: 50,
  maxX: LAYOUT_CONFIG.CANVAS_WIDTH - LAYOUT_CONFIG.NODE_WIDTH - 50,
  maxY: LAYOUT_CONFIG.CANVAS_HEIGHT - LAYOUT_CONFIG.NODE_HEIGHT - 50
};

// ========== ФУНКЦИИ МАСШТАБИРОВАНИЯ ==========
function updateTransform() {
    canvasTransform.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
    zoomLevelDisplay.textContent = `${Math.round(scale * 100)}%`;
    renderConnections();
    saveState();
}

function zoomToPoint(zoomFactor, clientX, clientY) {
    const rect = canvasContainer.getBoundingClientRect();
    const pointX = clientX - rect.left;
    const pointY = clientY - rect.top;

    const worldX = (pointX - translateX) / scale;
    const worldY = (pointY - translateY) / scale;

    scale = Math.max(ZOOM_CONFIG.min, Math.min(ZOOM_CONFIG.max, zoomFactor));

    translateX = pointX - worldX * scale;
    translateY = pointY - worldY * scale;

    updateTransform();
}

function zoomIn() {
    const newScale = Math.min(ZOOM_CONFIG.max, scale + ZOOM_CONFIG.step);
    const rect = canvasContainer.getBoundingClientRect();
    zoomToPoint(newScale, rect.width / 2, rect.height / 2);
}

function zoomOut() {
    const newScale = Math.max(ZOOM_CONFIG.min, scale - ZOOM_CONFIG.step);
    const rect = canvasContainer.getBoundingClientRect();
    zoomToPoint(newScale, rect.width / 2, rect.height / 2);
}

function resetZoom() {
    scale = ZOOM_CONFIG.default;
    translateX = 0;
    translateY = 0;
    updateTransform();
}

function centerOnRoot() {
    const root = byId('root');
    if(!root) return;

    const rootX = parseFloat(root.style.left) || LAYOUT_CONFIG.CANVAS_WIDTH / 2;
    const rootY = parseFloat(root.style.top) || LAYOUT_CONFIG.CANVAS_HEIGHT / 2;

    const containerWidth = canvasContainer.clientWidth;
    const containerHeight = canvasContainer.clientHeight;

    translateX = -rootX * scale + containerWidth / 2;
    translateY = -rootY * scale + containerHeight / 2;

    updateTransform();
}

// ОБРАБОТЧИКИ МАСШТАБИРОВАНИЯ
zoomInBtn.addEventListener('click', zoomIn);
zoomOutBtn.addEventListener('click', zoomOut);
resetZoomBtn.addEventListener('click', resetZoom);

// Добавляем кнопку центрирования в zoom-контролы
const zoomControls = document.querySelector('.zoom-controls');
const centerBtn = document.createElement('button');
centerBtn.className = 'zoom-btn';
centerBtn.id = 'centerRoot';
centerBtn.title = 'Центрировать на главном блоке';
centerBtn.textContent = '⌖';
zoomControls.appendChild(centerBtn);
centerBtn.addEventListener('click', centerOnRoot);

// МАСШТАБИРОВАНИЕ КОЛЕСОМ МЫШИ
canvasContainer.addEventListener('wheel', (e) => {
    e.preventDefault();

    const zoomFactor = e.deltaY > 0 ? scale - ZOOM_CONFIG.step : scale + ZOOM_CONFIG.step;
    zoomToPoint(zoomFactor, e.clientX, e.clientY);
});

// ПАННОРАМИРОВАНИЕ
canvasContainer.addEventListener('mousedown', (e) => {
    const target = e.target;
    if (target.closest('.node') || target.closest('.add-btn') || target.closest('.remove-btn') || target.closest('.title')) return;
    if (e.button !== 0) return;

    isPanning = true;
    panStart.x = e.clientX;
    panStart.y = e.clientY;
    startTranslate.x = translateX;
    startTranslate.y = translateY;

    canvasContainer.classList.add('canvas-panning');
    document.body.style.userSelect = 'none';
});

document.addEventListener('mousemove', (e) => {
    if (!isPanning) return;

    const dx = e.clientX - panStart.x;
    const dy = e.clientY - panStart.y;

    translateX = startTranslate.x + dx;
    translateY = startTranslate.y + dy;

    updateTransform();
});

document.addEventListener('mouseup', () => {
    if (!isPanning) return;
    isPanning = false;
    canvasContainer.classList.remove('canvas-panning');
    document.body.style.userSelect = '';
    saveState();
});

// ========== МОДАЛЬНОЕ ОКНО ==========
function showModal(title, text) {
    return new Promise((resolve) => {
        modalTitle.textContent = title;
        modalText.textContent = text;
        modalOverlay.classList.add('active');
        modalResolve = resolve;
    });
}

modalCancel.addEventListener('click', () => {
    modalOverlay.classList.remove('active');
    if (modalResolve) modalResolve(false);
});

modalConfirm.addEventListener('click', () => {
    modalOverlay.classList.remove('active');
    if (modalResolve) modalResolve(true);
});

modalOverlay.addEventListener('click', (e) => {
    if (e.target === modalOverlay) {
        modalOverlay.classList.remove('active');
        if (modalResolve) modalResolve(false);
    }
});

// ========== УПРАВЛЕНИЕ ПОЗИЦИЯМИ С ГРАНИЦАМИ ==========
let occupiedPositions = new Map();
let occupiedRectangles = new Map(); // Новый: храним реальные прямоугольники блоков

function resetOccupiedPositions() {
  occupiedPositions = new Map();
  occupiedRectangles = new Map();
}

function registerPosition(nodeId, x, y, width = LAYOUT_CONFIG.NODE_WIDTH, height = LAYOUT_CONFIG.NODE_HEIGHT) {
  const gridX = Math.floor(x / 30);
  const gridY = Math.floor(y / 30);
  const key = `${gridX}_${gridY}`;
  occupiedPositions.set(key, { nodeId, x, y });

  // Сохраняем реальные границы блока
  occupiedRectangles.set(nodeId, {
    id: nodeId,
    x: x,
    y: y,
    width: width,
    height: height,
    right: x + width,
    bottom: y + height
  });
}

// Функция проверки пересечения двух прямоугольников
function rectanglesIntersect(rect1, rect2, padding = 20) {
  return !(rect1.right <= rect2.x - padding ||
           rect1.x >= rect2.right + padding ||
           rect1.bottom <= rect2.y - padding ||
           rect1.y >= rect2.bottom + padding);
}

// Функция проверки пересечения с любым существующим блоком
function intersectsWithAnyBlock(x, y, width = LAYOUT_CONFIG.NODE_WIDTH, height = LAYOUT_CONFIG.NODE_HEIGHT, excludeId = null) {
  const testRect = {
    x: x,
    y: y,
    width: width,
    height: height,
    right: x + width,
    bottom: y + height
  };

  for (const [nodeId, rect] of occupiedRectangles) {
    if (excludeId && nodeId === excludeId) continue;
    if (rectanglesIntersect(testRect, rect)) {
      return { intersects: true, with: nodeId };
    }
  }
  return { intersects: false, with: null };
}

function isPositionFree(x, y, width = LAYOUT_CONFIG.NODE_WIDTH, height = LAYOUT_CONFIG.NODE_HEIGHT, excludeId = null) {
  // Проверяем границы с учетом размера блока
  if (x < BOUNDARIES.minX || y < BOUNDARIES.minY) {
    return false;
  }
  if (x + width > BOUNDARIES.maxX || y + height > BOUNDARIES.maxY) {
    return false;
  }

  // Проверяем пересечение с другими блоками
  return !intersectsWithAnyBlock(x, y, width, height, excludeId).intersects;
}

function getViewportCenter() {
  // Получаем центр видимой области
  const containerWidth = canvasContainer.clientWidth;
  const containerHeight = canvasContainer.clientHeight;

  // Преобразуем экранные координаты в мировые
  const worldX = (-translateX + containerWidth / 2) / scale;
  const worldY = (-translateY + containerHeight / 2) / scale;

  return {
    x: worldX - LAYOUT_CONFIG.NODE_WIDTH / 2,
    y: worldY - LAYOUT_CONFIG.NODE_HEIGHT / 2
  };
}

function findFreePosition(nearX, nearY, parentId = null, verticalOffset = 0) {
  // Если указан родитель, стараемся разместить под родительским блоком
  if (parentId) {
    const parentRect = occupiedRectangles.get(parentId);
    if (parentRect) {
      // Позиция под родителем с отступом
      let baseX = parentRect.x;
      let baseY = parentRect.bottom + LAYOUT_CONFIG.ROW_SPACING + verticalOffset;

      // Проверяем эту позицию
      if (isPositionFree(baseX, baseY)) {
        const clampedPos = clampToBoundaries(baseX, baseY);
        return { x: clampedPos.x, y: clampedPos.y };
      }

      // Если занято, ищем рядом
      for (let offset = 1; offset <= 10; offset++) {
        // Пробуем смещения вправо
        const rightX = parentRect.x + offset * 30;
        if (isPositionFree(rightX, baseY)) {
          const clampedPos = clampToBoundaries(rightX, baseY);
          return { x: clampedPos.x, y: clampedPos.y };
        }

        // Пробуем смещения влево
        const leftX = parentRect.x - offset * 30;
        if (isPositionFree(leftX, baseY)) {
          const clampedPos = clampToBoundaries(leftX, baseY);
          return { x: clampedPos.x, y: clampedPos.y };
        }
      }
    }
  }

  // Если координаты не указаны, используем центр видимой области
  let targetX = nearX;
  let targetY = nearY;

  if ((!targetX && targetX !== 0) || (!targetY && targetY !== 0)) {
    const viewportCenter = getViewportCenter();
    targetX = viewportCenter.x;
    targetY = viewportCenter.y;
  }

  // Сначала проверяем указанную позицию
  if (isPositionFree(targetX, targetY)) {
    const clampedPos = clampToBoundaries(targetX, targetY);
    return { x: clampedPos.x, y: clampedPos.y };
  }

  // Ищем свободное место по спирали от указанной точки
  for (let radius = 1; radius <= 15; radius++) {
    const points = 12;
    for (let i = 0; i < points; i++) {
      const angle = (i * 360) / points;
      const rad = angle * Math.PI / 180;
      const x = targetX + Math.cos(rad) * radius * 100;
      const y = targetY + Math.sin(rad) * radius * 80;

      if (isPositionFree(x, y)) {
        const clampedPos = clampToBoundaries(x, y);
        return { x: clampedPos.x, y: clampedPos.y };
      }
    }
  }

  // Если не нашли, возвращаем позицию в пределах границ
  const clampedPos = clampToBoundaries(targetX, targetY);
  return { x: clampedPos.x, y: clampedPos.y };
}

function clampToBoundaries(x, y, width = LAYOUT_CONFIG.NODE_WIDTH, height = LAYOUT_CONFIG.NODE_HEIGHT) {
  const clampedX = Math.max(BOUNDARIES.minX, Math.min(BOUNDARIES.maxX - width, x));
  const clampedY = Math.max(BOUNDARIES.minY, Math.min(BOUNDARIES.maxY - height, y));
  return { x: clampedX, y: clampedY };
}

// ========== СОХРАНЕНИЕ И ЗАГРУЗКА ==========
function saveState(debounceMs = 200){
  if(_saveTimeout) clearTimeout(_saveTimeout);
  _saveTimeout = setTimeout(()=> {
    try {
      const state = serializeState();
      localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    } catch(e){ console.error('saveState', e); }
  }, debounceMs);
}

function serializeState(){
  const nodes = Array.from(document.querySelectorAll('.node[data-id]')).map(n => ({
    id: n.dataset.id,
    left: parseFloat(n.style.left) || 0,
    top: parseFloat(n.style.top) || 0,
    title: n.querySelector('.title')?.innerText || '',
    type: n.dataset.type || '',
    collapsed: n.dataset.collapsed === 'true'
  }));

  const panelRect = sidePanel.getBoundingClientRect();
  const editorRect = document.getElementById('editorPage').getBoundingClientRect();
  const panelState = {
    left: panelRect.left - editorRect.left,
    top: panelRect.top - editorRect.top,
    width: panelRect.width,
    height: panelRect.height,
    collapsed: sidePanel.dataset.collapsed === '1',
    hidden: sidePanel.style.display === 'none'
  };

  const viewState = { scale, translateX, translateY };

  return {
    version: 3,
    nodes,
    edges,
    nodeCounter,
    aiOutput: document.getElementById('ai-output')?.innerHTML || '',
    isLockedUntil,
    viewState,
    panelState
  };
}

function loadState(){
  try {
    const raw = localStorage.getItem(STORAGE_KEY);

    // Всегда центрируем на корневом блоке при загрузке
    if(raw) {
      const s = JSON.parse(raw);
      if(s) {
        if(typeof s.nodeCounter === 'number') nodeCounter = s.nodeCounter;

        resetOccupiedPositions();

        if (s.viewState && s.version >= 3) {
          scale = s.viewState.scale || ZOOM_CONFIG.default;
          translateX = s.viewState.translateX || 0;
          translateY = s.viewState.translateY || 0;
        }

        const root = document.querySelector('[data-id="root"]');
        if(root){
          const savedRoot = (s.nodes || []).find(n=>n.id === 'root');
          if(savedRoot){
            const clampedPos = clampToBoundaries(savedRoot.left||0, savedRoot.top||0);
            root.style.left = clampedPos.x + 'px';
            root.style.top = clampedPos.y + 'px';
            const t = root.querySelector('.title');
            if(t) t.innerText = savedRoot.title || '';
            registerPosition('root', clampedPos.x, clampedPos.y);
          }
        }

        document.querySelectorAll('.node').forEach(n => { if(n.dataset.id !== 'root') n.remove(); });
        edges = [];

        if(Array.isArray(s.nodes)){
          s.nodes.forEach(n => {
            if(n.id === 'root') return;
            const clampedPos = clampToBoundaries(n.left || 100, n.top || 100);
            const node = recreateNode(n.id, clampedPos.x, clampedPos.y, n.title || 'Новый исход');
            if(n.type) node.dataset.type = n.type;
            if(n.collapsed) {
              node.dataset.collapsed = 'true';
              addToggleButton(node);
            }
            registerPosition(n.id, clampedPos.x, clampedPos.y);
          });
        }

        if(Array.isArray(s.edges)) edges = s.edges.slice();
        if(s.aiOutput !== undefined) document.getElementById('ai-output').innerHTML = s.aiOutput || '';

        if(s.panelState){
          const editorRect = document.getElementById('editorPage').getBoundingClientRect();
          sidePanel.style.left = (s.panelState.left || 0) + 'px';
          sidePanel.style.top = (s.panelState.top || 0) + 'px';
          sidePanel.style.right = 'auto';
          if(s.panelState.width) sidePanel.style.width = s.panelState.width + 'px';
          if(s.panelState.height) sidePanel.style.height = s.panelState.height + 'px';
          if(s.panelState.collapsed) sidePanel.dataset.collapsed = '1';
          if(s.panelState.hidden) {
            sidePanel.style.display = 'none';
            openPanelBtn.classList.add('visible');
          }
        }

        if(s.isLockedUntil){
          isLockedUntil = s.isLockedUntil;
          updateTimerUI();
          if(isLockedUntil > Date.now()){
            timerInterval && clearInterval(timerInterval);
            timerInterval = setInterval(updateTimerUI, 250);
          }
        }
      }
    } else {
      // Первый запуск - создаем корневой блок в центре
      const root = document.querySelector('[data-id="root"]');
      if(root) {
        const centerX = LAYOUT_CONFIG.CANVAS_WIDTH / 2 - LAYOUT_CONFIG.NODE_WIDTH / 2;
        const centerY = LAYOUT_CONFIG.CANVAS_HEIGHT / 2 - LAYOUT_CONFIG.NODE_HEIGHT / 2;

        root.style.left = centerX + 'px';
        root.style.top = centerY + 'px';
        registerPosition('root', centerX, centerY);
      }
    }

    // ВСЕГДА центрируем на корневом блоке после загрузки
    centerOnRoot();

    restoreCollapsedState();
    renderConnections();
    updateAIPreview();
  } catch(e){ console.error('loadState', e); }
}

// ========== ТАЙМЕР ==========
function setLock(seconds){
  isLockedUntil = Date.now() + seconds*1000;
  updateTimerUI();
  timerInterval && clearInterval(timerInterval);
  timerInterval = setInterval(updateTimerUI, 250);
  saveState();
}

function updateTimerUI(){
  const el = document.getElementById('ai-timer');
  const runBtn = document.getElementById('ai-run');
  const remaining = Math.max(0, Math.ceil((isLockedUntil - Date.now()) / 1000));
  if(remaining > 0){
    el.innerText = `${remaining}s`;
    runBtn.disabled = true;
    runBtn.style.opacity='0.6';
  } else {
    el.innerText = '—';
    runBtn.disabled = false;
    runBtn.style.opacity='';
    if(timerInterval){
      clearInterval(timerInterval);
      timerInterval=null;
    }
    if(isLockedUntil !== 0){
      isLockedUntil = 0;
      saveState();
    }
  }
}

// ========== УЗЛЫ И ИНТЕРФЕЙС ==========
function byId(id){ return document.querySelector(`[data-id="${id}"]`); }
function genId(){ nodeCounter = (nodeCounter||0) + 1; saveState(); return 'node-' + nodeCounter; }

function recreateNode(id, x=100, y=200, text='Новый исход'){
  const div = document.createElement('div');
  div.className = 'node';

  const clampedPos = clampToBoundaries(x, y);
  div.style.left = clampedPos.x + 'px';
  div.style.top = clampedPos.y + 'px';

  div.dataset.id = id;
  div.innerHTML = `
    <div contenteditable class="title">${text}</div>
    <div class="controls">
      <div class="small-muted">${id==='root' ? 'Главный пункт' : 'Исход'}</div>
      <div class="buttons-container">
        <div class="add-btn" title="Добавить исход" data-add>+</div>
        ${id==='root' ? '' : '<div class="remove-btn" title="Удалить узел">✕</div>'}
      </div>
    </div>
  `;
  canvasContent.appendChild(div);
  makeDraggable(div);
  setupNodeButtons(div);
  const t = div.querySelector('.title');
  if(t) t.addEventListener('input', ()=>{ updateAIPreview(); saveState(); });

  // Регистрируем блок
  registerPosition(id, clampedPos.x, clampedPos.y, div.offsetWidth, div.offsetHeight);

  return div;
}

function createNode(x=100, y=200, text='Новый исход', parentId=null, type=null){
  const id = genId();

  // Определяем вертикальный отступ в зависимости от типа
  let verticalOffset = 0;
  if (type === 'pro' || type === 'con') {
    // Для плюсов/минусов используем PRO_CON_SPACING
    verticalOffset = LAYOUT_CONFIG.PRO_CON_SPACING * 1.5; // Уменьшено
  }

  const freePos = findFreePosition(x, y, parentId, verticalOffset);

  const node = recreateNode(id, freePos.x, freePos.y, text);
  if(type) node.dataset.type = type;
  if(parentId) addEdge(parentId, id);

  updateAIPreview();
  renderConnections();
  saveState();
  return id;
}

function makeDraggable(elem){
  let dragging=false, startX=0, startY=0, origLeft=0, origTop=0;
  const nodeId = elem.dataset.id;
  let lastRenderTime = 0;
  const RENDER_THROTTLE_MS = 16; // ~60fps

  elem.addEventListener('mousedown', e=>{
    if(e.target.closest('.add-btn, .remove-btn, .toggle-btn')) return;
    if(e.target.closest('.title')) return;
    dragging=true;
    startX=e.clientX;
    startY=e.clientY;
    origLeft=parseFloat(elem.style.left)||0;
    origTop=parseFloat(elem.style.top)||0;
    e.preventDefault();
    elem.style.zIndex = '1000';
  });

  document.addEventListener('mousemove', e=>{
    if(!dragging) return;

    const dx=e.clientX-startX;
    const dy=e.clientY-startY;

    let newLeft = origLeft+dx;
    let newTop = origTop+dy;

    // Применяем границы при перемещении
    const clampedPos = clampToBoundaries(newLeft, newTop);
    newLeft = clampedPos.x;
    newTop = clampedPos.y;

    // Проверяем пересечение с другими блоками
    const intersection = intersectsWithAnyBlock(newLeft, newTop,
                                                elem.offsetWidth, elem.offsetHeight,
                                                nodeId);

    if (!intersection.intersects) {
      elem.style.left=newLeft+'px';
      elem.style.top=newTop+'px';

      // Троттлинг перерисовки соединений
      const now = Date.now();
      if (now - lastRenderTime >= RENDER_THROTTLE_MS) {
        renderConnections();
        lastRenderTime = now;
      }
    }
  });

  document.addEventListener('mouseup', ()=>{
    if(!dragging) return;
    dragging=false;
    elem.style.zIndex='';

    const finalLeft = parseFloat(elem.style.left)||0;
    const finalTop = parseFloat(elem.style.top)||0;

    // Обновляем позицию в системе
    occupiedRectangles.delete(nodeId);
    registerPosition(nodeId, finalLeft, finalTop, elem.offsetWidth, elem.offsetHeight);

    // Финальная перерисовка
    renderConnections();
    saveState();
  });
}


function setupNodeButtons(node){
  const addBtn = node.querySelector('[data-add]');
  const removeBtn = node.querySelector('.remove-btn');
  const toggleBtn = node.querySelector('.toggle-btn');

  if(addBtn) addBtn.addEventListener('click', e=>{
    e.stopPropagation();
    const nodeId = node.dataset.id;
    const nodeRect = occupiedRectangles.get(nodeId);

    if (!nodeRect) return;

    // Находим позицию под текущим блоком
    const freePos = findFreePosition(nodeRect.x, nodeRect.bottom + 20, nodeId);

    createNode(freePos.x, freePos.y, 'Новый пункт', nodeId);
  });

  if(removeBtn) removeBtn.addEventListener('click', e=>{
    e.stopPropagation();
    removeNode(node.dataset.id);
  });

  if(toggleBtn) toggleBtn.addEventListener('click', e=>{
    e.stopPropagation();
    toggleCollapse(node);
  });
}

function addToggleButton(node) {
  const buttonsContainer = node.querySelector('.buttons-container');
  if (!buttonsContainer) return;

  if (!buttonsContainer.querySelector('.toggle-btn')) {
    const toggleBtn = document.createElement('div');
    toggleBtn.className = 'toggle-btn';
    toggleBtn.title = 'Свернуть/развернуть';
    toggleBtn.textContent = '−';
    buttonsContainer.appendChild(toggleBtn);
    setupNodeButtons(node);
  }
}

// РЕКУРСИВНОЕ СВОРАЧИВАНИЕ ВСЕХ ПОСЛЕДУЮЩИХ БЛОКОВ
function toggleCollapse(node) {
  const isCollapsed = node.dataset.collapsed === 'true';
  node.dataset.collapsed = (!isCollapsed).toString();

  const toggleBtn = node.querySelector('.toggle-btn');
  if (toggleBtn) {
    toggleBtn.textContent = isCollapsed ? '−' : '+';
  }

  collapseAllChildren(node, !isCollapsed);
  saveState();
}

function collapseAllChildren(parentNode, shouldCollapse) {
  const parentId = parentNode.dataset.id;

  const childNodes = findAllChildNodes(parentId);

  childNodes.forEach(childNode => {
    if (shouldCollapse) {
      childNode.classList.add('hidden');
    } else {
      childNode.classList.remove('hidden');
      // После раскрытия перерисовываем соединения
      setTimeout(() => {
        renderConnections();
      }, 50);
    }

    const childToggleBtn = childNode.querySelector('.toggle-btn');
    if (childToggleBtn && childNode.dataset.type &&
        (childNode.dataset.type.includes('container') || childNode.dataset.collapsed === 'true')) {
      childToggleBtn.textContent = shouldCollapse ? '+' : '−';
    }
  });

  renderConnections();
}

function findAllChildNodes(parentId) {
  const children = [];
  const visited = new Set();

  function findChildrenRecursive(id) {
    if (visited.has(id)) return;
    visited.add(id);

    edges.forEach(edge => {
      if (edge.from === id) {
        const childNode = byId(edge.to);
        if (childNode && !children.includes(childNode)) {
          children.push(childNode);
          findChildrenRecursive(edge.to);
        }
      }
    });
  }

  findChildrenRecursive(parentId);
  return children;
}

function restoreCollapsedState() {
  document.querySelectorAll('.node[data-collapsed="true"]').forEach(node => {
    collapseAllChildren(node, true);
  });
}

function getAllProConConnections() {
  const proConNodes = Array.from(document.querySelectorAll('.node[data-id]'))
    .filter(n => {
      const nodeType = n.dataset.type;
      return nodeType && (nodeType.includes('pro') || nodeType.includes('con'));
    });

  console.log('Found pro/con nodes:', proConNodes.length);
  proConNodes.forEach(node => {
    console.log('Node:', node.dataset.id, 'type:', node.dataset.type, 'title:', node.querySelector('.title')?.innerText);
  });
}

function removeNode(id){
  const node = byId(id);
  if(!node) return;

  const childEdges = edges.filter(e => e.from === id);
  childEdges.forEach(e => removeNode(e.to));

  edges = edges.filter(e => e.from !== id && e.to !== id);

  // Удаляем из системы
  occupiedRectangles.delete(id);

  node.remove();
  updateAIPreview();
  renderConnections();
  saveState();
}

function addEdge(fromId, toId){
  edges.push({from: fromId, to: toId});
  renderConnections();
}

function renderConnections(){
  const svg = connectorsSvg;
  svg.innerHTML = '';

  edges.forEach(e => {
    const fromNode = byId(e.from);
    const toNode = byId(e.to);
    if(!fromNode || !toNode) return;

    if (fromNode.classList.contains('hidden') || toNode.classList.contains('hidden')) return;

    const fromX = parseFloat(fromNode.style.left) + fromNode.offsetWidth / 2;
    const fromY = parseFloat(fromNode.style.top) + fromNode.offsetHeight;
    const toX = parseFloat(toNode.style.left) + toNode.offsetWidth / 2;
    const toY = parseFloat(toNode.style.top);

    // Определяем тип соединения для регулировки кривизны
    const fromType = fromNode.dataset.type || '';
    const toType = toNode.dataset.type || '';

    // Определяем, является ли соединение между плюсами/минусами
    const isProConConnection =
      (fromType.includes('pro') && toType.includes('pro')) ||
      (fromType.includes('con') && toType.includes('con'));

    // Для отладки - выводим в консоль
    if (isProConConnection) {
      console.log('Pro/Con connection detected:', e.from, '->', e.to, 'types:', fromType, toType);
    }

    // Определяем смещение для кривизны
    let controlOffset;

    // Для почти вертикальных соединений делаем прямую линию
    const horizontalDistance = Math.abs(toX - fromX);
    const verticalDistance = Math.abs(toY - fromY);

    if (horizontalDistance < 50 || isProConConnection) {
      // Прямая линия для почти вертикальных соединений и плюсов/минусов
      controlOffset = 5; // Минимальное смещение для плавности
    } else {
      // Стандартная кривая для других соединений
      controlOffset = Math.min(horizontalDistance * 0.3, 80);
    }

    // Для плюсов/минусов делаем почти прямую линию
    if (isProConConnection) {
      controlOffset = 2; // Почти прямая линия
    }

    const pathData = `M ${fromX} ${fromY}
                     C ${fromX} ${fromY + controlOffset},
                       ${toX} ${toY - controlOffset},
                       ${toX} ${toY}`;

    // Глоу эффект
    const glow = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    glow.setAttribute('d', pathData);
    glow.setAttribute('stroke', 'rgba(0,217,255,0.15)');
    glow.setAttribute('stroke-width', isProConConnection ? '4' : '8');
    glow.setAttribute('fill', 'none');
    glow.setAttribute('stroke-linecap', 'round');
    glow.style.filter = 'blur(8px)';
    svg.appendChild(glow);

    // Основная линия
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('d', pathData);

    // Цвет линии в зависимости от типа
    let strokeColor = 'var(--neon)';
    if (fromType.includes('pro') || toType.includes('pro')) {
      strokeColor = 'var(--pro-color)';
    } else if (fromType.includes('con') || toType.includes('con')) {
      strokeColor = 'var(--con-color)';
    }

    path.setAttribute('stroke', strokeColor);
    path.setAttribute('stroke-width', isProConConnection ? '1.5' : '3');
    path.setAttribute('fill', 'none');
    path.setAttribute('stroke-linecap', 'round');
    path.style.filter = isProConConnection ? 'none' : 'drop-shadow(0 0 6px rgba(0,217,255,0.3))';
    svg.appendChild(path);

    // Стрелка только для не-плюсов/минусов соединений
    if (!isProConConnection) {
      const arrowSize = 8;
      const angle = Math.atan2(toY - (fromY + controlOffset), toX - fromX);

      const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
      const points = `
        ${toX},${toY}
        ${toX - arrowSize * Math.cos(angle - Math.PI/6)},${toY - arrowSize * Math.sin(angle - Math.PI/6)}
        ${toX - arrowSize * Math.cos(angle + Math.PI/6)},${toY - arrowSize * Math.sin(angle + Math.PI/6)}
      `;
      arrow.setAttribute('points', points);
      arrow.setAttribute('fill', strokeColor);
      arrow.style.filter = 'drop-shadow(0 0 4px rgba(0,217,255,0.5))';
      svg.appendChild(arrow);
    }
  });
}


// ========== AI И ПАРСИНГ ==========
function collectTreeText(){
  const root = byId('root');
  const title = root ? root.querySelector('.title').innerText.trim() : '';

  const outcomes = Array.from(document.querySelectorAll('.node[data-id]:not([data-id="root"])'))
                    .filter(n => {
                      const nodeType = n.dataset.type;
                      return !nodeType || (nodeType !== 'pro' && nodeType !== 'con' && nodeType !== 'pros-container' && nodeType !== 'cons-container');
                    })
                    .map(n => n.querySelector('.title').innerText.trim())
                    .filter(Boolean);

  return { title, outcomes };
}

function updateAIPreview(){
  const {title,outcomes} = collectTreeText();
  document.getElementById('ai-title').innerText = title || '—';
  document.getElementById('ai-outcomes').innerText = outcomes.length ? ('• ' + outcomes.join('\n• ')) : '—';
}

// УЛУЧШЕННАЯ ФУНКЦИЯ ПАРСИНГА
function parseProsConsFromText(text){
  if(!text) return { description: '', pros: [], cons: [] };

  const normalized = text.replace(/\r\n/g,'\n').replace(/\r/g,'\n').trim();

  let description = '';
  let pros = [];
  let cons = [];

  // Пытаемся найти структурированные разделы
  const prosMatch = normalized.match(/ПЛЮСЫ?[:\s]*([^]*?)(?=\s*МИНУСЫ?|$)/i);
  const consMatch = normalized.match(/МИНУСЫ?[:\s]*([^]*?)$/i);

  // Если есть структурированные разделы, парсим их
  if (prosMatch || consMatch) {
    // Описание - все что до первого раздела
    if (prosMatch) {
      description = normalized.substring(0, prosMatch.index).trim();
    } else if (consMatch) {
      description = normalized.substring(0, consMatch.index).trim();
    }

    // Парсим плюсы
    if (prosMatch && prosMatch[1]) {
      const prosText = prosMatch[1].trim();
      pros = prosText.split('\n')
        .map(item => item.trim().replace(/^[\-\*\•\d\.\s]+/, ''))
        .filter(item => item && item.length > 2)
        .slice(0, 6);
    }

    // Парсим минусы
    if (consMatch && consMatch[1]) {
      const consText = consMatch[1].trim();
      cons = consText.split('\n')
        .map(item => item.trim().replace(/^[\-\*\•\d\.\s]+/, ''))
        .filter(item => item && item.length > 2)
        .slice(0, 6);
    }
  } else {
    // Если нет структурированных разделов, используем весь текст как описание
    description = normalized;
    // И генерируем стандартные плюсы/минусы
    pros = ["Высокая эффективность", "Быстрая реализация"];
    cons = ["Риск неудачи", "Ограниченный масштаб"];
  }

  // Очищаем описание от маркеров списков
  description = description.replace(/^[\-\*\•\d\.\s]+/gm, '').trim();

  return { description, pros, cons };
}

// ОБНОВЛЕННАЯ ФУНКЦИЯ СОЗДАНИЯ ВЕТОК ПЛЮСОВ И МИНУСОВ
function createProConNodesForOutcome(outcomeText, pros, cons, outcomeIndex){
  const nodes = Array.from(document.querySelectorAll('.node[data-id]'));

  // Ищем узел с соответствующим текстом, который не является контейнером плюсов/минусов
  let outcomeNode = nodes.find(n => {
    const nodeText = (n.querySelector('.title')?.innerText || '').trim();
    const nodeType = n.dataset.type;
    return nodeText === outcomeText &&
           !nodeType &&
           n.dataset.id !== 'root';
  });

  if(!outcomeNode){
    const root = byId('root');
    const rootX = parseFloat(root.style.left) || 0;
    const rootY = parseFloat(root.style.top) || 0;

    // Создаем новый исход под корневым узлом с отступом
    const x = rootX;
    const y = rootY + (outcomeIndex + 1) * LAYOUT_CONFIG.ROW_SPACING;

    // Корректируем позицию, чтобы не выходить за границы
    const clampedY = Math.min(y, BOUNDARIES.maxY - LAYOUT_CONFIG.NODE_HEIGHT);

    createNode(x, clampedY, outcomeText, 'root');

    // Ждем немного и пытаемся найти созданный узел
    setTimeout(() => {
      const newNodes = Array.from(document.querySelectorAll('.node[data-id]'));
      outcomeNode = newNodes.find(n => {
        const nodeText = (n.querySelector('.title')?.innerText || '').trim();
        const nodeType = n.dataset.type;
        return nodeText === outcomeText &&
               !nodeType &&
               n.dataset.id !== 'root';
      });

      if(outcomeNode) {
        createProConBranches(outcomeNode, pros, cons, outcomeIndex);
      }
    }, 200);
  } else {
    createProConBranches(outcomeNode, pros, cons, outcomeIndex);
  }
}

// ИСПРАВЛЕННАЯ ФУНКЦИЯ СОЗДАНИЯ ВЕТОК ПЛЮСОВ И МИНУСОВ
function createProConBranches(outcomeNode, pros, cons, outcomeIndex){
  const outcomeId = outcomeNode.dataset.id;
  const outcomeRect = occupiedRectangles.get(outcomeId);

  if (!outcomeRect) return;

  // Создаем контейнер для плюсов СЛЕВА и НИЖЕ
  if(pros.length > 0) {
    // Находим позицию слева и ниже основного блока
    const proContainerX = outcomeRect.x - LAYOUT_CONFIG.HORIZONTAL_OFFSET;
    const proContainerY = outcomeRect.bottom + 40;

    // Корректируем позицию, чтобы не выходить за границы
    const clampedProX = Math.max(BOUNDARIES.minX, proContainerX);
    const clampedProY = Math.min(proContainerY, BOUNDARIES.maxY - LAYOUT_CONFIG.NODE_HEIGHT);

    const prosContainerId = createNode(clampedProX, clampedProY, 'Плюсы', outcomeId, 'pros-container');
    const prosContainer = byId(prosContainerId);

    prosContainer.dataset.collapsed = 'true';
    addToggleButton(prosContainer);

    // Создаем плюсы как отдельные блоки с соединениями ВНИЗ друг за другом
    let previousProId = prosContainerId;
    let currentProY = clampedProY + LAYOUT_CONFIG.NODE_HEIGHT + LAYOUT_CONFIG.PRO_CON_SPACING / 2; // ИСПРАВЛЕНО: используем PRO_CON_SPACING

    pros.forEach((pro, idx) => {
      // Рассчитываем вертикальную позицию с учетом отступов
      const proX = clampedProX;
      const proY = currentProY;

      // Корректируем позицию, чтобы не выходить за границы
      const clampedProItemY = Math.min(proY, BOUNDARIES.maxY - LAYOUT_CONFIG.NODE_HEIGHT);

      const proId = createNode(proX, clampedProItemY, pro, previousProId, 'pro');
      previousProId = proId;

      // Обновляем позицию для следующего блока
      const proNode = byId(proId);
      if (proNode) {
        currentProY = parseFloat(proNode.style.top) + proNode.offsetHeight + LAYOUT_CONFIG.PRO_CON_SPACING / 3; // ИСПРАВЛЕНО: используем PRO_CON_SPACING
      }
    });

    collapseAllChildren(prosContainer, true);
  }

  // Создаем контейнер для минусов СПРАВА и НИЖЕ
  if(cons.length > 0) {
    // Находим позицию справа и ниже основного блока
    const conContainerX = outcomeRect.x + LAYOUT_CONFIG.HORIZONTAL_OFFSET;
    const conContainerY = outcomeRect.bottom + 40;

    // Корректируем позицию, чтобы не выходить за границы
    const clampedConX = Math.min(conContainerX, BOUNDARIES.maxX - LAYOUT_CONFIG.NODE_WIDTH);
    const clampedConY = Math.min(conContainerY, BOUNDARIES.maxY - LAYOUT_CONFIG.NODE_HEIGHT);

    const consContainerId = createNode(clampedConX, clampedConY, 'Минусы', outcomeId, 'cons-container');
    const consContainer = byId(consContainerId);

    consContainer.dataset.collapsed = 'true';
    addToggleButton(consContainer);

    // Создаем минусы как отдельные блоки с соединениями ВНИЗ друг за другом
    let previousConId = consContainerId;
    let currentConY = clampedConY + LAYOUT_CONFIG.NODE_HEIGHT + LAYOUT_CONFIG.PRO_CON_SPACING / 2; // ИСПРАВЛЕНО: используем PRO_CON_SPACING

    cons.forEach((con, idx) => {
      // Рассчитываем вертикальную позицию с учетом отступов
      const conX = clampedConX;
      const conY = currentConY;

      // Корректируем позицию, чтобы не выходить за границы
      const clampedConItemY = Math.min(conY, BOUNDARIES.maxY - LAYOUT_CONFIG.NODE_HEIGHT);

      const conId = createNode(conX, clampedConItemY, con, previousConId, 'con');
      previousConId = conId;

      // Обновляем позицию для следующего блока
      const conNode = byId(conId);
      if (conNode) {
        currentConY = parseFloat(conNode.style.top) + conNode.offsetHeight + LAYOUT_CONFIG.PRO_CON_SPACING / 3; // ИСПРАВЛЕНО: используем PRO_CON_SPACING
      }
    });

    collapseAllChildren(consContainer, true);
  }

  setTimeout(() => {
    renderConnections();
    saveState();
  }, 200);
}

// ========== СБРОС ОТВЕТОВ AI ==========
async function resetAIResponses() {
  const result = await showModal('Сброс ответов', 'Удалить все плюсы и минусы, созданные ИИ? Исходные варианты решений останутся.');
  if (!result) return;

  const proConNodes = Array.from(document.querySelectorAll('.node[data-id]:not([data-id="root"])'))
    .filter(n => {
      const nodeType = n.dataset.type;
      return nodeType && (nodeType.includes('pro') || nodeType.includes('con') || nodeType.includes('pros-container') || nodeType.includes('cons-container'));
    });

  proConNodes.forEach(node => {
    const nodeId = node.dataset.id;
    edges = edges.filter(e => e.from !== nodeId && e.to !== nodeId);

    // Удаляем из системы
    occupiedRectangles.delete(nodeId);

    node.remove();
  });

  document.getElementById('ai-output').innerHTML = '';
  updateTimerUI();
  updateAIPreview();
  renderConnections();
  saveState();
}

// ========== ЗАПРОСЫ К СЕРВЕРУ ==========
async function sendAiRequestWithRetries(payload, maxRetries = MAX_RETRIES){
  let lastError = null;
  for(let attempt = 1; attempt <= maxRetries; attempt++){
    try{
      const res = await fetch('/run-ai-life', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify(payload)
      });

      if(!res.ok){
        lastError = new Error('HTTP ' + res.status);
      } else {
        const data = await res.json();
        return { success: true, data };
      }
    } catch(err){ lastError = err; }

    const backoff = 200 * attempt;
    await new Promise(r => setTimeout(r, backoff));
  }
  return { success: false, error: lastError };
}

// ========== AI UI ==========
const aiRunBtn = document.getElementById('ai-run');
const aiResetBtn = document.getElementById('ai-reset');

aiRunBtn.addEventListener('click', async ()=>{
  if(isLockedUntil > Date.now()) return;

  const { title, outcomes } = collectTreeText();
  const outBox = document.getElementById('ai-output');

  if(!title){
    outBox.innerText = 'Пожалуйста, опишите проблему.';
    return;
  }

  if(!outcomes.length){
    outBox.innerText = 'Добавьте варианты решения.';
    return;
  }

  outBox.innerHTML = '';
  const loading = document.createElement('div');
  loading.className = 'ai-response';
  loading.innerHTML = `<div class="meta"><b>Анализируем ${outcomes.length} исходов...</b></div>`;
  outBox.appendChild(loading);
  outBox.scrollTop = outBox.scrollHeight;

  aiRunBtn.disabled = true;
  aiRunBtn.style.opacity = '0.6';

  const payload = { title, outcomes };
  const result = await sendAiRequestWithRetries(payload, MAX_RETRIES);

  if(result.success){
    const data = result.data || {};
    const results = Array.isArray(data.results) ? data.results : [];

    if(outBox.lastElementChild === loading) outBox.removeChild(loading);

    if(results.length === 0){
      const empty = document.createElement('div');
      empty.className = 'ai-response';
      empty.innerText = 'Пустой результат от сервера.';
      outBox.appendChild(empty);
    } else {
      results.forEach((item, index) => {
        const block = document.createElement('div');
        block.className = 'ai-response result-highlight';
        const outcomeText = item.outcome || outcomes[index] || `Исход ${index + 1}`;
        const resultText = item.result || '';

        const { description, pros, cons } = parseProsConsFromText(resultText);

        // ИСПРАВЛЕННЫЙ ВЫВОД - всегда показываем описание, плюсы и минусы
        block.innerHTML = `
          <div class="meta"><b>Исход ${index + 1}:</b> ${escapeHtml(outcomeText)}</div>

          <div style="margin-top: 8px;">
            <div style="color: var(--text-primary); font-weight: 600; font-size: 12px;">📝 Анализ:</div>
            <div style="font-size: 12px; line-height: 1.4; margin-top: 4px; color: var(--text-muted);">
              ${description ? escapeHtml(description) : escapeHtml(resultText)}
            </div>
          </div>

          ${pros.length > 0 ? `
            <div style="margin-top: 12px;">
              <div style="color: var(--pro-color); font-weight: 600; font-size: 12px;">✅ Плюсы:</div>
              <ul class="pros-list">
                ${pros.map(pro => `<li>${escapeHtml(pro)}</li>`).join('')}
              </ul>
            </div>
          ` : ''}

          ${cons.length > 0 ? `
            <div style="margin-top: 12px;">
              <div style="color: var(--con-color); font-weight: 600; font-size: 12px;">❌ Минусы:</div>
              <ul class="cons-list">
                ${cons.map(con => `<li>${escapeHtml(con)}</li>`).join('')}
              </ul>
            </div>
          ` : ''}
        `;

        outBox.appendChild(block);

        if(pros.length > 0 || cons.length > 0) {
          createProConNodesForOutcome(outcomeText, pros, cons, index);
        }
      });
    }

    setLock(60);
    saveState();
  } else {
    if(outBox.lastElementChild === loading) {
      loading.innerHTML = `<div class="meta"><b>Ошибка при запросе к AI. Попытки исчерпаны.</b></div>`;
    } else {
      const err = document.createElement('div');
      err.className = 'ai-response';
      err.innerText = 'Ошибка при запросе к AI. Попытки исчерпаны.';
      outBox.appendChild(err);
    }
    console.error('AI request failed', result.error);
  }

  aiRunBtn.disabled = false;
  aiRunBtn.style.opacity = '';
});

aiResetBtn.addEventListener('click', resetAIResponses);

// ========== ПАНЕЛЬ (ПЕРЕМЕЩЕНИЕ И УПРАВЛЕНИЕ) ==========
let panelDragging = false;
let panelResizing = false;
let panelStartX = 0;
let panelStartY = 0;
let panelStartWidth = 0;
let panelStartHeight = 0;
let panelStartLeft = 0;
let panelStartTop = 0;

sideHeader.addEventListener('mousedown', e => {
  if(e.target.closest('button')) return;
  panelDragging = true;
  panelStartX = e.clientX;
  panelStartY = e.clientY;
  panelStartLeft = parseInt(sidePanel.style.left) || 0;
  panelStartTop = parseInt(sidePanel.style.top) || 0;
  sidePanel.style.right = 'auto';
  document.body.style.userSelect = 'none';
  e.preventDefault();
});

panelHandle.addEventListener('mousedown', e => {
  panelResizing = true;
  panelStartX = e.clientX;
  panelStartY = e.clientY;
  panelStartWidth = sidePanel.offsetWidth;
  panelStartHeight = sidePanel.offsetHeight;
  document.body.style.userSelect = 'none';
  e.preventDefault();
});

document.addEventListener('mousemove', e => {
  if(panelDragging){
    const dx = e.clientX - panelStartX;
    const dy = e.clientY - panelStartY;
    sidePanel.style.left = (panelStartLeft + dx) + 'px';
    sidePanel.style.top = (panelStartTop + dy) + 'px';
  }
  if(panelResizing){
    const dx = e.clientX - panelStartX;
    const newWidth = Math.max(300, Math.min(800, panelStartWidth - dx));
    sidePanel.style.width = newWidth + 'px';
    renderConnections();
  }
});

document.addEventListener('mouseup', () => {
  if(panelDragging || panelResizing){
    panelDragging = false;
    panelResizing = false;
    document.body.style.userSelect = '';
    saveState();
  }
});

panelCollapseBtn.addEventListener('click', () => {
  if(sidePanel.dataset.collapsed === '1'){
    sidePanel.style.width = '320px';
    sidePanel.style.height = 'calc(100vh - 40px)';
    sidePanel.dataset.collapsed = '0';
  } else {
    sidePanel.style.width = '60px';
    sidePanel.style.height = '60px';
    sidePanel.dataset.collapsed = '1';
  }
  saveState();
});

panelCloseBtn.addEventListener('click', () => {
  sidePanel.style.display = 'none';
  openPanelBtn.classList.add('visible');
  saveState();
});

openPanelBtn.addEventListener('click', () => {
  sidePanel.style.display = 'flex';
  openPanelBtn.classList.remove('visible');
  saveState();
});

// ========== ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ ==========
function escapeHtml(s){
  if(!s && s!==0) return '';
  return String(s)
    .replaceAll('&','&amp;')
    .replaceAll('<','&lt;')
    .replaceAll('>','&gt;')
    .replaceAll('"','&quot;')
    .replaceAll("'",'&#39;');
}

// ========== ИНИЦИАЛИЗАЦИЯ ==========
function init(){
  loadState();
  updateTimerUI();
  updateAIPreview();

  const root = byId('root');
  if(root){
    makeDraggable(root);
    setupNodeButtons(root);
    const t = root.querySelector('.title');
    if(t) t.addEventListener('input', ()=>{ updateAIPreview(); saveState(); });
  }

  // Double-click on canvas to create new node
  canvasContent.addEventListener('dblclick', e => {
    const target = e.target;
    if(target.closest('.node') || target.closest('.add-btn') || target.closest('.remove-btn')) return;

    const rect = canvasContent.getBoundingClientRect();
    const x = e.clientX - rect.left - LAYOUT_CONFIG.NODE_WIDTH / 2;
    const y = e.clientY - rect.top - LAYOUT_CONFIG.NODE_HEIGHT / 2;

    createNode(x, y, 'Новый исход');
  });

  // Auto-save on title edits
  document.addEventListener('input', e => {
    if(e.target.classList.contains('title')){
      updateAIPreview();
      saveState();
    }
  });

  // Periodically save state
  setInterval(saveState, 30000);
}
init();
</script>
</body>
</html>
