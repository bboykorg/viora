<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Поток Кадров — Viora</title>
  <link rel="stylesheet" href="/static/styles.css">
  <!-- DOMPurify для безопасной вставки HTML -->
  <script src="https://cdn.jsdelivr.net/npm/dompurify@2.4.0/dist/purify.min.js"></script>
  <style>
    /* небольшой локальный CSS для placeholder и кнопок, остальное в styles.css */
    .title[contenteditable]:empty:before { content: attr(data-placeholder); color: rgba(255,255,255,0.35); display:block; }
    .ai-box pre { white-space: pre-wrap; word-break: break-word; }
    .add-btn.blink { animation: blink .35s linear; }
    @keyframes blink { 0%{transform:scale(1)}50%{transform:scale(1.08)}100%{transform:scale(1)} }
    .ai-box {
      max-height: 300px;
      overflow-y: auto;
      background: rgba(255,255,255,0.02);
      padding: 10px;
      border-radius: 8px;
      font-size: 14px;
      line-height: 1.4;
    }
    .ai-box .ai-response {
      margin-bottom: 12px;
      padding: 8px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.04);
      background: rgba(255,255,255,0.02);
    }
    .ai-box .ai-response pre { margin: 8px 0 0 0; font-family: inherit; }
    /* визуальные отличия для плюсов/минусов нод */
    .node[data-type="pro"] { box-shadow: 0 6px 18px rgba(45, 212, 191, 0.06); border-color: rgba(45,212,191,0.15); }
    .node[data-type="con"] { box-shadow: 0 6px 18px rgba(249,115,22,0.06); border-color: rgba(249,115,22,0.15); }
  </style>
</head>
<body>
  <a class="back-link" href="/">← Назад</a>

  <div class="editor-page">
    <div class="canvas-area" id="canvasArea">
      <svg class="connector-svg" id="connectors" width="100%" height="100%"></svg>

      <div class="node" id="node-root" style="left:calc(50% - 130px); top:80px;" data-id="root">
        <div contenteditable class="title" data-placeholder="Опишите главный кадр...">Опишите главный кадр</div>
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div class="small-muted">Главный кадр</div>
          <div class="add-btn" title="Добавить исход">+</div>
        </div>
      </div>
    </div>

    <div class="side-panel">
      <h3>ИИ-режиссёр (Поток кадров)</h3>
      <div class="small-muted">У каждого кадра допускается только один следующий кадр (один исход). Чтобы заменить исход — сначала удалите существующий у крестика на нём.</div>

      <div style="height:12px"></div>
      <div style="font-weight:600">Главный кадр</div>
      <div id="ai-title" class="small-muted">—</div>

      <div style="height:10px"></div>
      <div style="font-weight:600">Исход (единственный)</div>
      <div id="ai-outcome" class="small-muted">—</div>

      <div style="height:12px"></div>
      <div class="ai-box" id="ai-output">Нажмите «Предложить кадр», чтобы ИИ сгенерировал следующий кадр на основе заданного.</div>

      <div style="height:12px"></div>
      <div style="display:flex;gap:10px">
        <button class="button-primary" id="ai-run">Предложить кадр</button>
        <button class="button-ghost" id="ai-clear">Очистить все исходы</button>
      </div>

      <div style="height:10px"></div>
      <div class="small-muted">Таймер блокировки: <span id="ai-timer">—</span></div>

    </div>
  </div>

<script>
/* ========== Конфигурация и state ========== */
const STORAGE_KEY = 'viora_flow_state_v1';
const canvas = document.getElementById('canvasArea');
const connectorsSvg = document.getElementById('connectors');
let edges = []; // [{from,to},...]
let nodeCounter = 1;
const MAX_RETRIES = 4;
let isLockedUntil = 0;
let timerInterval = null;
let _saveTimeout = null;

/* ---------- Сохранение/загрузка состояния (localStorage) ---------- */
function saveState(debounceMs = 200) {
  if (_saveTimeout) clearTimeout(_saveTimeout);
  _saveTimeout = setTimeout(() => {
    try {
      const state = serializeState();
      localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      //console.log('saved', state);
    } catch (e) {
      console.error('saveState error', e);
    }
  }, debounceMs);
}

function serializeState() {
  const nodes = Array.from(document.querySelectorAll('.node[data-id]')).map(n => ({
    id: n.dataset.id,
    left: parseFloat(n.style.left) || 0,
    top: parseFloat(n.style.top) || 0,
    title: n.querySelector('.title')?.innerText || '',
    type: n.dataset.type || ''
  }));
  return {
    version: 1,
    nodes,
    edges,
    nodeCounter,
    aiOutput: document.getElementById('ai-output')?.innerHTML || '',
    isLockedUntil,
    canvasScroll: { left: canvas.scrollLeft, top: canvas.scrollTop }
  };
}

function loadState() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return;
    const state = JSON.parse(raw);
    if (!state) return;

    if (typeof state.nodeCounter === 'number') nodeCounter = state.nodeCounter;

    // restore root
    const root = document.querySelector('[data-id="root"]');
    if (root) {
      const savedRoot = (state.nodes || []).find(n => n.id === 'root');
      if (savedRoot) {
        root.style.left = (savedRoot.left || 0) + 'px';
        root.style.top = (savedRoot.top || 0) + 'px';
        const t = root.querySelector('.title');
        if (t) t.innerText = savedRoot.title || '';
      }
    }

    // remove other nodes
    document.querySelectorAll('.node').forEach(n => { if (n.dataset.id !== 'root') n.remove(); });
    edges = [];

    // recreate nodes
    if (Array.isArray(state.nodes)) {
      state.nodes.forEach(n => {
        if (n.id === 'root') return;
        recreateNode(n.id, n.left || 100, n.top || 100, n.title || 'Новый исход', n.type || '');
      });
    }

    if (Array.isArray(state.edges)) edges = state.edges.slice();
    if (state.aiOutput !== undefined) document.getElementById('ai-output').innerHTML = state.aiOutput || '';

    if (state.isLockedUntil) {
      isLockedUntil = state.isLockedUntil;
      updateTimerUI();
      if (isLockedUntil > Date.now()) {
        if (timerInterval) clearInterval(timerInterval);
        timerInterval = setInterval(updateTimerUI, 250);
      }
    }

    if (state.canvasScroll) {
      requestAnimationFrame(() => {
        canvas.scrollLeft = state.canvasScroll.left || 0;
        canvas.scrollTop = state.canvasScroll.top || 0;
        renderConnections();
      });
    }

    renderConnections();
    updateAIPreview();
  } catch (e) {
    console.error('loadState error', e);
  }
}

/* ---------- Таймер блокировки ========== */
function setLock(seconds) {
  isLockedUntil = Date.now() + seconds * 1000;
  updateTimerUI();
  if (timerInterval) clearInterval(timerInterval);
  timerInterval = setInterval(updateTimerUI, 250);
  saveState();
}

function updateTimerUI() {
  const timerEl = document.getElementById('ai-timer');
  const runBtn = document.getElementById('ai-run');
  const remaining = Math.max(0, Math.ceil((isLockedUntil - Date.now()) / 1000));
  if (remaining > 0) {
    timerEl.innerText = `${remaining}s`;
    runBtn.disabled = true;
    runBtn.style.opacity = '0.6';
  } else {
    timerEl.innerText = '—';
    runBtn.disabled = false;
    runBtn.style.opacity = '';
    if (timerInterval) { clearInterval(timerInterval); timerInterval = null; }
    if (isLockedUntil !== 0) { isLockedUntil = 0; saveState(); }
  }
}

/* ---------- Помощники (DOM) ---------- */
function byId(id) { return document.querySelector(`[data-id="${id}"]`); }
function nextId() { nodeCounter = (nodeCounter || 0) + 1; saveState(); return 'node-' + Date.now() + '-' + Math.floor(Math.random()*1000) + '-' + nodeCounter; }

/* ---------- Создание / воссоздание нод ---------- */
function recreateNode(id, x = 100, y = 200, text = 'Новый исход', type = '') {
  const div = document.createElement('div');
  div.className = 'node';
  div.style.left = x + 'px';
  div.style.top = y + 'px';
  div.dataset.id = id;
  if (type) div.dataset.type = type;
  div.innerHTML = `
    <div contenteditable class="title">${text}</div>
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div class="small-muted">${id === 'root' ? 'Главный кадр' : 'Кадр'}</div>
      <div style="display:flex;gap:8px;align-items:center">
        <div class="add-btn" title="Добавить исход">+</div>
        ${id === 'root' ? '' : '<div class="remove-btn" title="Удалить узел">✕</div>'}
      </div>
    </div>
  `;
  canvas.appendChild(div);
  makeDraggable(div);
  setupNodeButtons(div);
  const t = div.querySelector('.title');
  if (t) t.addEventListener('input', () => { updateAIPreview(); saveState(); });
  return id;
}

function createNodeAt(x, y, text, parentId) {
  const id = nextId();
  recreateNode(id, x, y, text, '');
  if (parentId) {
    edges.push({ from: parentId, to: id });
    const parent = byId(parentId);
    if (parent) { parent.dataset.childId = id; const btn = parent.querySelector('.add-btn'); if (btn) btn.setAttribute('disabled', ''); }
  }
  updateAIPreview();
  renderConnections();
  saveState();
  return id;
}

/* ---------- Drag (мышь/тач) ---------- */
function makeDraggable(elem) {
  let dragging = false, startX = 0, startY = 0, origLeft = 0, origTop = 0;
  const canvasRect = () => canvas.getBoundingClientRect();

  elem.addEventListener('mousedown', (e) => {
    if (e.target.closest('.add-btn') || e.target.closest('.remove-btn')) return;
    if (e.target.closest('.title') || e.target.isContentEditable) return;
    const rect = elem.getBoundingClientRect();
    startX = e.clientX; startY = e.clientY;
    origLeft = rect.left - canvasRect().left; origTop = rect.top - canvasRect().top;
    dragging = true;
    elem.style.zIndex = 1000;
  });

  document.addEventListener('mousemove', (e) => {
    if (!dragging) return;
    const cr = canvasRect();
    let nx = origLeft + (e.clientX - startX), ny = origTop + (e.clientY - startY);
    nx = Math.max(8, nx); ny = Math.max(8, ny);
    elem.style.left = nx + 'px'; elem.style.top = ny + 'px';
    renderConnections();
  });

  document.addEventListener('mouseup', () => {
    if (dragging) { dragging = false; elem.style.zIndex = ''; saveState(); }
  });

  // touch
  elem.addEventListener('touchstart', (e) => {
    const t = e.touches && e.touches[0]; if (!t) return;
    const target = document.elementFromPoint(t.clientX, t.clientY); if (!target) return;
    if (target.closest('.add-btn') || target.closest('.remove-btn') || target.closest('.title')) return;
    const rect = elem.getBoundingClientRect();
    startX = t.clientX; startY = t.clientY; origLeft = rect.left - canvas.getBoundingClientRect().left; origTop = rect.top - canvas.getBoundingClientRect().top;
    dragging = true; elem.style.zIndex = 1000; e.preventDefault();
  }, { passive: false });

  document.addEventListener('touchmove', (e) => {
    if (!dragging) return;
    const t = e.touches && e.touches[0]; if (!t) return;
    const rect = canvas.getBoundingClientRect();
    let nx = origLeft + (t.clientX - startX), ny = origTop + (t.clientY - startY);
    nx = Math.max(8, nx); ny = Math.max(8, ny);
    elem.style.left = nx + 'px'; elem.style.top = ny + 'px';
    renderConnections(); e.preventDefault();
  }, { passive: false });

  document.addEventListener('touchend', () => { if (dragging) { dragging = false; elem.style.zIndex = ''; saveState(); } });
}

/* ---------- Кнопки нод (add/remove) ---------- */
function setupNodeButtons(nodeElem) {
  const addBtn = nodeElem.querySelector('.add-btn');
  const removeBtn = nodeElem.querySelector('.remove-btn');
  const titleEl = nodeElem.querySelector('.title');

  if (titleEl) {
    titleEl.addEventListener('mousedown', (e) => e.stopPropagation());
    titleEl.addEventListener('touchstart', (e) => e.stopPropagation(), { passive: false });
    titleEl.addEventListener('input', () => { updateAIPreview(); saveState(); });
  }

  if (addBtn) addBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    if (nodeElem.dataset.childId) { addBtn.classList.add('blink'); setTimeout(() => addBtn.classList.remove('blink'), 350); return; }
    const rect = nodeElem.getBoundingClientRect(); const cr = canvas.getBoundingClientRect();
    const x = rect.left - cr.left + rect.width + 40; const y = rect.top - cr.top;
    createNodeAt(x, y, 'Следующий кадр...', nodeElem.dataset.id);
  });

  if (removeBtn) removeBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    removeNode(nodeElem.dataset.id);
  });
}

/* ---------- Удаление нод (с пересоединением детей) ---------- */
function removeNode(nodeId) {
  const node = byId(nodeId); if (!node) return;
  // remove edges that reference node
  for (let i = edges.length - 1; i >= 0; i--) {
    if (edges[i].from === nodeId || edges[i].to === nodeId) edges.splice(i, 1);
  }
  node.remove();
  renderConnections();
  updateAIPreview();
  saveState();
}

/* ---------- Отрисовка связей ---------- */
function renderConnections() {
  connectorsSvg.innerHTML = '';
  edges.forEach(e => {
    const a = byId(e.from), b = byId(e.to);
    if (!a || !b) return;
    const ra = a.getBoundingClientRect(), rb = b.getBoundingClientRect();
    const cr = canvas.getBoundingClientRect();
    const x1 = ra.left + ra.width/2 - cr.left, y1 = ra.top + ra.height - cr.top;
    const x2 = rb.left + rb.width/2 - cr.left, y2 = rb.top - cr.top;
    const dx = Math.max(40, Math.abs(x2 - x1) / 2);
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('d', `M ${x1} ${y1} C ${x1} ${y1+dx} ${x2} ${y2-dx} ${x2} ${y2}`);
    path.setAttribute('stroke', 'rgba(255,255,255,0.12)');
    path.setAttribute('stroke-width', '2');
    path.setAttribute('fill', 'none');
    connectorsSvg.appendChild(path);
  });
}

/* ---------- Сбор дерева для AI (линейный поток: root -> child -> child ...) ---------- */
function collectTreeForAI() {
  const root = byId('root');
  const seen = [];
  function traverse(id) {
    const node = byId(id);
    if (!node) return;
    const txt = node.querySelector('.title')?.innerText.trim() || '';
    seen.push({ id, text: txt });
    // ищем child edge
    const childEdge = edges.find(e => e.from === id);
    if (childEdge && childEdge.to) traverse(childEdge.to);
  }
  traverse('root');
  return seen;
}

function updateAIPreview() {
  const tree = collectTreeForAI();
  const title = tree.length ? tree[0].text : '';
  const outcome = tree.length > 1 ? tree[1].text : '';
  document.getElementById('ai-title').innerText = title || '—';
  document.getElementById('ai-outcome').innerText = outcome || '—';
}

/* ---------- Парсер плюсов/минусов из текста ИИ ---------- */
function parseProsConsFromText(text) {
  if (!text) return { pros: [], cons: [] };
  const normalized = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
  const lines = normalized.split('\n').map(l => l.trim()).filter(Boolean);
  const pros = [], cons = [];
  lines.forEach(l => {
    // убираем маркеры
    const clean = l.replace(/^[\-\u2022\*\d\.\)\s]+/, '').trim();
    // простые эвристики: "Плюс", "Минус", "+", "-"
    if (/^(плюс|плюсы|плюс:)/i.test(l) || /^\+/.test(l)) {
      const value = clean.replace(/^(плюс[:\s]*)/i, '').trim();
      if (value) pros.push(value);
    } else if (/^(минус|минусы|минус:)/i.test(l) || /^\-/.test(l)) {
      const value = clean.replace(/^(минус[:\s]*)/i, '').trim();
      if (value) cons.push(value);
    }
  });

  // если не найдено явно — попытаемся найти в одном абзаце "Плюсы: ... Минусы: ..."
  if (pros.length === 0 && cons.length === 0) {
    const m = normalized.match(/плюс(?:ы)?[:\s]*([\s\S]*?)(?:минус|$)/i);
    if (m && m[1]) pros.push(...m[1].split(/[;\/]\s*|\n/).map(s => s.trim()).filter(Boolean));
    const m2 = normalized.match(/минус(?:ы)?[:\s]*([\s\S]*?)(?:$)/i);
    if (m2 && m2[1]) cons.push(...m2[1].split(/[;\/]\s*|\n/).map(s => s.trim()).filter(Boolean));
  }

  // fallback: несколько предложений — берем первое предложение как плюс, второе как минус (очень грубая эвристика)
  if (pros.length === 0 && cons.length === 0) {
    const sentences = normalized.split(/[.\n]/).map(s => s.trim()).filter(Boolean);
    if (sentences.length >= 1) pros.push(sentences[0]);
    if (sentences.length >= 2) cons.push(sentences[1]);
  }

  // уникальность и трим
  const uniq = arr => Array.from(new Set(arr.map(s => s.trim()))).slice(0, 10);
  return { pros: uniq(pros), cons: uniq(cons) };
}

/* ---------- Создание нод плюсов/минусов рядом с исходом ---------- */
function createProConNodesForOutcome(outcomeText, pros, cons) {
  // найдем ноду с текстом исхода
  const nodes = Array.from(document.querySelectorAll('.node[data-id]'));
  let outcomeNode = nodes.find(n => (n.querySelector('.title')?.innerText || '').trim() === outcomeText.trim());
  // если не нашли — создадим новую исход-ноду рядом с корнем
  if (!outcomeNode) {
    const root = byId('root');
    const rr = root.getBoundingClientRect(); const cr = canvas.getBoundingClientRect();
    const x = rr.left - cr.left + rr.width + 40; const y = rr.top - cr.top;
    const newId = createNodeAt(x, y, outcomeText, 'root');
    outcomeNode = byId(newId);
  }
  if (!outcomeNode) return;

  const parentId = outcomeNode.dataset.id;
  const rect = outcomeNode.getBoundingClientRect(); const cr = canvas.getBoundingClientRect();
  const baseX = rect.left - cr.left + rect.width + 40;
  let yBase = rect.top - cr.top + rect.height + 18;
  const gap = 84;

  // плюсы сверху, минусы ниже
  pros.forEach((p, idx) => {
    const x = baseX;
    const y = yBase + idx * gap;
    const id = createNodeAt(x, y, 'Плюс: ' + p, parentId);
    const n = byId(id); if (n) n.dataset.type = 'pro';
  });
  const consStart = yBase + (pros.length) * gap + 6;
  cons.forEach((c, idx) => {
    const x = baseX;
    const y = consStart + idx * gap;
    const id = createNodeAt(x, y, 'Минус: ' + c, parentId);
    const n = byId(id); if (n) n.dataset.type = 'con';
  });

  renderConnections();
  saveState();
}

/* ---------- Взаимодействие с сервером (fetch + ретраи) ---------- */
async function sendAiRequestWithRetries(payload, maxRetries = MAX_RETRIES) {
  let lastError = null;
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const res = await fetch('/run-ai', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      if (!res.ok) {
        lastError = new Error('HTTP ' + res.status);
      } else {
        const data = await res.json();
        return { success: true, data };
      }
    } catch (err) {
      lastError = err;
    }
    const backoff = 200 * attempt;
    await new Promise(r => setTimeout(r, backoff));
  }
  return { success: false, error: lastError };
}

/* ---------- Кнопки AI ---------- */
const aiRunBtn = document.getElementById('ai-run');
const aiClearBtn = document.getElementById('ai-clear');

aiRunBtn.addEventListener('click', async () => {
  if (isLockedUntil > Date.now()) return;

  const tree = collectTreeForAI();
  const title = tree.length ? tree[0].text : '';
  const outcome = tree.length > 1 ? tree[1].text : '';
  const outBox = document.getElementById('ai-output');

  if (!title) { outBox.innerText = 'Опишите главный кадр.'; return; }
  if (!outcome) { outBox.innerText = 'Добавьте хотя бы один исход (нажмите + у нужного кадра).'; return; }

  // очищаем окно ответов ТУТ (как вы просили), показываем индикатор
  outBox.innerHTML = '';
  const loading = document.createElement('div');
  loading.className = 'ai-response';
  loading.innerText = 'Запрос отправлен...';
  outBox.appendChild(loading);
  outBox.scrollTop = outBox.scrollHeight;

  aiRunBtn.disabled = true; aiRunBtn.style.opacity = '0.6';

  const payload = { title, outcomes: [outcome] };
  const result = await sendAiRequestWithRetries(payload, MAX_RETRIES);

  if (result.success) {
    const data = result.data || {};
    // поддерживаем разные форматы ответа сервера:
    // 1) old style: { model1, result1, model2, result2 }
    // 2) new style: { title, results: [{ index, outcome, result }, ...] }
    if (Array.isArray(data.results) && data.results.length > 0) {
      // множественные результаты
      outBox.innerHTML = '';
      data.results.forEach(item => {
        const block = document.createElement('div');
        block.className = 'ai-response';
        const resText = item.result || '';
        const outText = item.outcome || '';
        block.innerHTML = `<div><b>Исход ${escapeHtml(item.index || '')}:</b> ${escapeHtml(outText)}</div><pre>${escapeHtml(resText)}</pre>`;
        outBox.appendChild(block);
        // парсим плюсы/минусы и создаём ноды
        const { pros, cons } = parseProsConsFromText(resText);
        if ((pros && pros.length) || (cons && cons.length)) createProConNodesForOutcome(outText, pros, cons);
      });
    } else if (typeof data.result1 === 'string' || typeof data.result2 === 'string') {
      // legacy style
      outBox.innerHTML = '';
      const r1 = String(data.result1 || '');
      const r2 = String(data.result2 || '');
      const block = document.createElement('div'); block.className = 'ai-response';
      block.innerHTML = `${DOMPurify.sanitize('<div><b>' + escapeHtml(data.model1 || 'model1') + ':</b></div><pre>' + escapeHtml(r1) + '</pre>')}
                         <div style="height:8px"></div>
                         ${DOMPurify.sanitize('<div><b>' + escapeHtml(data.model2 || 'model2') + ':</b></div><pre>' + escapeHtml(r2) + '</pre>')}`;
      outBox.appendChild(block);

      // попробуем применить парсер к первому непустому result
      const combined = r1 || r2 || '';
      const parsed = parseProsConsFromText(combined);
      if ((parsed.pros.length || parsed.cons.length)) createProConNodesForOutcome(outcome, parsed.pros, parsed.cons);
    } else {
      // неожиданный формат — если есть поле 'result' используем его
      const singleText = data.result || (data.results && data.results[0] && data.results[0].result) || '';
      outBox.innerHTML = '';
      const block = document.createElement('div'); block.className = 'ai-response';
      block.innerHTML = `<pre>${escapeHtml(String(singleText))}</pre>`;
      outBox.appendChild(block);
      const parsed = parseProsConsFromText(String(singleText));
      if ((parsed.pros.length || parsed.cons.length)) createProConNodesForOutcome(outcome, parsed.pros, parsed.cons);
    }

    // скроллим и ставим блокировку
    outBox.scrollTop = outBox.scrollHeight;
    setLock(60);
    saveState();
  } else {
    // ошибка
    if (outBox.lastElementChild === loading) {
      loading.innerText = 'Ошибка при запросе к AI. Попытки исчерпаны.';
    } else {
      const err = document.createElement('div'); err.className = 'ai-response'; err.innerText = 'Ошибка при запросе к AI. Попытки исчерпаны.'; outBox.appendChild(err);
    }
    console.error('AI request failed after retries:', result.error);
  }

  aiRunBtn.disabled = false; aiRunBtn.style.opacity = '';
});

/* ---------- Очистка исходов (удалить все ноды кроме root) ---------- */
aiClearBtn.addEventListener('click', () => {
  const all = Array.from(document.querySelectorAll('.node')).map(n => n.dataset.id);
  for (const id of all) { if (id !== 'root') {
    const n = byId(id);
    if (n) n.remove();
  } }
  edges = [];
  const root = byId('root'); if (root) { delete root.dataset.childId; const btn = root.querySelector('.add-btn'); if (btn) btn.removeAttribute('disabled'); }
  renderConnections(); updateAIPreview(); document.getElementById('ai-output').innerText = 'Все исходы удалены.'; saveState();
});

/* ---------- Малые утилиты ---------- */
function escapeHtml(str) {
  if (!str && str !== 0) return '';
  return String(str).replaceAll('&', '&amp;').replaceAll('<', '&lt;').replaceAll('>', '&gt;').replaceAll('"', '&quot;').replaceAll("'", '&#39;');
}

/* ---------- Инициализация UI / события ---------- */
document.querySelectorAll('.node').forEach(n => {
  makeDraggable(n);
  setupNodeButtons(n);
  const titleEl = n.querySelector('.title');
  if (titleEl) titleEl.addEventListener('input', () => { updateAIPreview(); saveState(); });
});

// save scroll
canvas.addEventListener('scroll', () => { saveState(); renderConnections(); });
window.addEventListener('resize', renderConnections);
window.addEventListener('beforeunload', () => {
  try { localStorage.setItem(STORAGE_KEY, JSON.stringify(serializeState())); } catch (e) {}
});

// initial render & load saved
updateAIPreview();
renderConnections();
updateTimerUI();
loadState();
</script>
</body>
</html>
