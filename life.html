<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Путь Жизни — Viora</title>
<link rel="stylesheet" href="styles.css">
<style>
/* Локальные стили для Путь Жизни */
:root{--bg:rgba(10,10,15,0.45);--panel:rgba(8,8,10,0.6);--primary:#ffd166}
*{box-sizing:border-box}
body{margin:0;font-family:Inter, system-ui, sans-serif;background:#0b0b0f;color:#fff}
.editor-page { width:100vw; height:100vh; display:flex; gap:20px; padding:20px; align-items:stretch; }
.canvas-area { flex:1 1 auto; border-radius:18px; background: var(--bg); backdrop-filter: blur(8px); position:relative; overflow:auto; padding:40px; min-height:80vh; }
.side-panel { width:420px; max-width:40%; background: var(--panel); border-radius:16px; padding:18px; box-shadow:0 8px 30px rgba(0,0,0,0.6); color:#fff; }
.node { width:220px; min-height:56px; background: rgba(255,255,255,0.03); border:1px solid rgba(255,255,255,0.08); border-radius:14px; padding:12px; position:absolute; display:flex; flex-direction:column; gap:8px; cursor:move; }
.node .title { font-weight:600; font-size:14px; color:#fff; outline:none; min-height:20px; }
.controls { display:flex; gap:8px; justify-content:flex-end; align-items:center; }
.add-btn, .remove-btn { width:28px; height:28px; border-radius:8px; display:inline-flex; align-items:center; justify-content:center; cursor:pointer; user-select:none; border:1px solid rgba(255,255,255,0.06); background: rgba(255,255,255,0.04); }
.remove-btn { background: rgba(255,255,255,0.02); }
.add-btn[disabled] { opacity:0.45; cursor:not-allowed; }
.connector-svg { position:absolute; inset:0; pointer-events:none; }
.small-muted { color: rgba(255,255,255,0.6); font-size:13px; }
.ai-box { background: rgba(255,255,255,0.02); padding:12px; border-radius:10px; min-height:120px; overflow:auto; color:#fff; }
.action-row { display:flex; gap:10px; margin-top:12px; }
.button-primary { background:var(--primary); color:#0a0a0f; padding:10px 12px; border-radius:10px; cursor:pointer; border:none; font-weight:600; }
.button-ghost { background:transparent; color:#fff; border:1px solid rgba(255,255,255,0.08); padding:10px 12px; border-radius:10px; cursor:pointer; }
.title[contenteditable]:empty:before { content: attr(data-placeholder); color: rgba(255,255,255,0.35); display:block; }

/* фиксированная белая кнопка назад */
.back-link {
  position: fixed;
  top: 12px;
  left: 12px;
  z-index: 9999;
  background: rgba(255,255,255,0.06);
  color: #ffffff;
  text-decoration: none;
  display: inline-flex;
  align-items:center;
  gap:8px;
  padding:8px 10px;
  border-radius:10px;
  border: 1px solid rgba(255,255,255,0.08);
  font-weight: 600;
  box-shadow: 0 6px 20px rgba(0,0,0,0.5);
}
</style>
</head>
<body>
  <a class="back-link" href="/viora">← Назад</a>

  <div class="editor-page">
    <div class="canvas-area" id="canvasArea">
      <svg class="connector-svg" id="connectors" width="100%" height="100%"></svg>

      <!-- root node -->
      <div class="node" data-id="root" id="node-root" style="left: calc(50% - 110px); top: 80px;">
        <div class="title" contenteditable data-placeholder="Опишите проблему...">Нажмите и впишите проблему</div>
        <div class="controls">
          <div class="small-muted">Главный пункт</div>
          <div class="add-btn" title="Добавить исход" data-add>+</div>
          <div class="remove-btn" title="Удалить узел">✕</div>
        </div>
      </div>
    </div>

    <div class="side-panel">
      <h3>ИИ-помощник</h3>
      <div class="small-muted">Он читает заголовок (проблему) и все исходы, затем предлагает наиболее комфортный вариант.</div>

      <div style="height:14px"></div>

      <div style="font-weight:600">Заголовок (проблема)</div>
      <div id="ai-title" class="small-muted" style="min-height:34px"></div>

      <div style="height:10px"></div>
      <div style="font-weight:600">Исходы (варианты решения)</div>
      <div id="ai-outcomes" class="small-muted" style="min-height:60px"></div>

      <div style="height:12px"></div>
      <div class="ai-box" id="ai-output">Нажмите «Предложить», чтобы ИИ проанализировал варианты.</div>

      <div class="action-row">
        <button class="button-primary" id="ai-run">Предложить</button>
        <button class="button-ghost" id="ai-reset">Сбросить подсказку</button>
      </div>

      <div style="height:10px"></div>
      <div class="small-muted">Поддержка: узлы редактируемы, перетаскивайте их, нажмите «+» на узле чтобы создать исход. У исходов есть та же логика.</div>
    </div>
  </div>

<script>
/* --- Логика редактора для life.html --- */

const canvas = document.getElementById('canvasArea');
const connectorsSvg = document.getElementById('connectors');
let nodeCounter = 1;
const edges = []; // {from, to}

// Утилиты
function byId(id) { return document.querySelector(`[data-id="${id}"]`); }

// Создание нового узла (можно указать parentId или null)
function createNode(x=120,y=120,text='Новый исход', parentId=null) {
  const id = 'node-' + (++nodeCounter);
  const div = document.createElement('div');
  div.className = 'node';
  div.dataset.id = id;
  div.style.left = x + 'px';
  div.style.top = y + 'px';
  div.innerHTML = `
    <div class="title" contenteditable data-placeholder="Описание...">${text}</div>
    <div class="controls">
      <div class="small-muted">Исход</div>
      <div class="add-btn" title="Добавить исход">+</div>
      <div class="remove-btn" title="Удалить узел">✕</div>
    </div>
  `;
  canvas.appendChild(div);
  makeDraggable(div);
  setupNodeButtons(div);

  if (parentId) {
    edges.push({from: parentId, to: id});
  }
  renderConnections();
  updateAIPreview();
  return id;
}

// Перетаскивание
function makeDraggable(elem) {
  let dragging=false, dx=0, dy=0;
  elem.addEventListener('mousedown', (e) => {
    if (e.target.closest('.add-btn') || e.target.closest('.remove-btn')) return;
    dragging = true;
    const rect = elem.getBoundingClientRect();
    const canvasRect = canvas.getBoundingClientRect();
    dx = e.clientX - rect.left;
    dy = e.clientY - rect.top;
    elem.style.zIndex = 1000;
  });
  document.addEventListener('mousemove', (e) => {
    if (!dragging) return;
    const rect = canvas.getBoundingClientRect();
    let nx = e.clientX - rect.left - dx;
    let ny = e.clientY - rect.top - dy;
    if (nx < 8) nx = 8;
    if (ny < 8) ny = 8;
    elem.style.left = nx + 'px';
    elem.style.top = ny + 'px';
    renderConnections();
  });
  document.addEventListener('mouseup', () => {
    if (dragging) {
      dragging = false;
      elem.style.zIndex = '';
    }
  });
}

// Рисуем кривые между узлами
function renderConnections() {
  connectorsSvg.innerHTML = '';
  edges.forEach(e => {
    const a = byId(e.from);
    const b = byId(e.to);
    if (!a || !b) return;
    const ra = a.getBoundingClientRect();
    const rb = b.getBoundingClientRect();
    const canvasRect = canvas.getBoundingClientRect();
    const x1 = ra.left + ra.width/2 - canvasRect.left;
    const y1 = ra.top + ra.height - canvasRect.top;
    const x2 = rb.left + rb.width/2 - canvasRect.left;
    const y2 = rb.top - canvasRect.top;
    const path = document.createElementNS('http://www.w3.org/2000/svg','path');
    const dx = Math.max(40, Math.abs(x2-x1)/2);
    path.setAttribute('d', `M ${x1} ${y1} C ${x1} ${y1+dx} ${x2} ${y2-dx} ${x2} ${y2}`);
    path.setAttribute('stroke','rgba(255,255,255,0.12)');
    path.setAttribute('stroke-width','2');
    path.setAttribute('fill','none');
    connectorsSvg.appendChild(path);
  });
}

// Настройка кнопок узла
function setupNodeButtons(nodeElem) {
  const addBtn = nodeElem.querySelector('.add-btn');
  const removeBtn = nodeElem.querySelector('.remove-btn');
  const title = nodeElem.querySelector('.title');

  addBtn && addBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    const rect = nodeElem.getBoundingClientRect();
    const canvasRect = canvas.getBoundingClientRect();
    const x = rect.left - canvasRect.left + rect.width + 30;
    const y = rect.top - canvasRect.top;
    const newId = createNode(x, y, 'Вариант решения...', nodeElem.dataset.id);
    const newTitle = byId(newId).querySelector('.title');
    newTitle && newTitle.focus();
  });

  removeBtn && removeBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    const id = nodeElem.dataset.id;
    removeNode(id);
  });

  title && title.addEventListener('input', updateAIPreview);
}

// Собрать дерево/список текстов для AI-превью
function collectTreeText() {
  const root = byId('root');
  const title = root ? (root.querySelector('.title').innerText.trim()) : '';
  // все узлы кроме root
  const outcomes = Array.from(document.querySelectorAll('.node[data-id]'))
    .filter(n => n.dataset.id !== 'root')
    .map(n => n.querySelector('.title').innerText.trim())
    .filter(Boolean);
  return { title, outcomes };
}
function updateAIPreview() {
  const { title, outcomes } = collectTreeText();
  document.getElementById('ai-title').innerText = title || '—';
  document.getElementById('ai-outcomes').innerText = outcomes.length ? ('• ' + outcomes.join('\n• ')) : '—';
}

// Примитивный scorer
function scoreOutcome(text, title) {
  const positive = ['легко','быстро','безопасно','комфорт','просто','меньше','удобн'];
  const negatives = ['дорого','риск','опасн','сложно','трудн'];
  let score = 0;
  const t = text.toLowerCase();
  positive.forEach(p => { if (t.includes(p)) score += 2; });
  negatives.forEach(n => { if (t.includes(n)) score -= 2; });
  if (t.length < 25) score += 1;
  if (t.length > 120) score -= 1;
  (title.toLowerCase().split(/\W+/)).forEach(w => { if (w.length>3 && t.includes(w)) score += 0.5; });
  return score + Math.random()*0.4;
}

// --- Новая функция удаления: дети не удаляются, а переназначаются на родителя ---
function removeNode(nodeId) {
  const node = byId(nodeId);
  if (!node) return;

  // найти индекс ребра parent -> node (если есть)
  const parentEdgeIndex = edges.findIndex(e => e.to === nodeId);
  const parentId = parentEdgeIndex !== -1 ? edges[parentEdgeIndex].from : null;

  // найти все ребра node -> child*
  const childEdges = [];
  for (let i = 0; i < edges.length; i++) {
    if (edges[i].from === nodeId) childEdges.push({ index: i, to: edges[i].to });
  }

  if (parentId) {
    // переназначаем всех детей на родителя (parent -> child)
    childEdges.forEach(ce => {
      // если такого ребра ещё нет — добавляем
      const exists = edges.some(e => e.from === parentId && e.to === ce.to);
      if (!exists) edges.push({ from: parentId, to: ce.to });
    });

    // удаляем старые ребра node->child (обход в обратном порядке)
    for (let i = childEdges.length - 1; i >= 0; i--) {
      edges.splice(childEdges[i].index, 1);
    }

    // удаляем ребро parent->node
    if (parentEdgeIndex !== -1) edges.splice(parentEdgeIndex, 1);
  } else {
    // нет родителя: просто удаляем ребра node->child — дети станут верхнего уровня
    for (let i = edges.length - 1; i >= 0; i--) {
      if (edges[i].from === nodeId) edges.splice(i,1);
    }
    // также удалить ребро parent->node если есть (на всякий случай)
    if (parentEdgeIndex !== -1) edges.splice(parentEdgeIndex,1);
  }

  // удалить сам DOM-узел
  node.remove();

  // обновления
  renderConnections();
  updateAIPreview();
}

// Обработчики AI-кнопок
document.getElementById('ai-run').addEventListener('click', () => {
  const { title, outcomes } = collectTreeText();
  const out = document.getElementById('ai-output');
  if (!title) { out.innerText = 'Пожалуйста, опишите проблему.'; return; }
  if (!outcomes.length) { out.innerText = 'Добавьте варианты решения.'; return; }
  const scored = outcomes.map(o => ({ text: o, score: scoreOutcome(o, title) }));
  scored.sort((a,b) => b.score - a.score);
  const best = scored[0];
  out.innerText = `Проблема: «${title}».\n\nЛучший вариант: «${best.text}».\n\nПояснение: содержит позитивные признаки и сбалансирован по сложности.`;
});
document.getElementById('ai-reset').addEventListener('click', () => {
  document.getElementById('ai-output').innerText = 'Сброшено.';
});

// Инициализация: повесить драг/кнопки на уже существующие узлы
document.querySelectorAll('.node').forEach(n => {
  makeDraggable(n);
  setupNodeButtons(n);
});

// перерисовка при ресайзе/скролле
window.addEventListener('resize', renderConnections);
canvas.addEventListener('scroll', renderConnections);

// стартовое обновление
renderConnections();
updateAIPreview();
</script>
</body>
</html>
