<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Поток Кадров — Viora</title>
<link rel="stylesheet" href="static/styles.css">
<style>
:root{--bg:rgba(10,10,15,0.45);--panel:rgba(8,8,10,0.6)}
.editor-page { width:100vw; height:100vh; display:flex; gap:20px; padding:20px; align-items:stretch; box-sizing:border-box; font-family:Inter, system-ui, sans-serif; }
.canvas-area { flex:1 1 auto; border-radius:18px; background: var(--bg); backdrop-filter: blur(8px); position:relative; overflow:auto; padding:40px; min-height:80vh;}
.side-panel { width:420px; max-width:40%; background: var(--panel); border-radius:16px; padding:18px; box-shadow:0 8px 30px rgba(0,0,0,0.6); color:#fff; }
.node { width:260px; min-height:56px; background: rgba(255,255,255,0.03); border:1px solid rgba(255,255,255,0.08); border-radius:14px; padding:12px; box-sizing:border-box; position:absolute; display:flex; flex-direction:column; gap:8px; cursor:move; }
.add-btn { width:28px; height:28px; border-radius:8px; display:inline-flex; align-items:center; justify-content:center; background: rgba(255,255,255,0.04); border:1px solid rgba(255,255,255,0.06); cursor:pointer; user-select:none; }
.add-btn[disabled] { opacity:0.45; cursor:not-allowed; transform:none; }
.remove-btn { width:26px; height:26px; border-radius:8px; display:inline-flex; align-items:center; justify-content:center; background: rgba(255,255,255,0.02); border:1px solid rgba(255,255,255,0.06); cursor:pointer; }
.connector-svg { position:absolute; inset:0; pointer-events:none; }
.small-muted { color: rgba(255,255,255,0.6); font-size:13px; }
.button-primary { background:var(--color-primary); color:#0a0a0f; padding:10px 12px; border-radius:10px; cursor:pointer; border:none; }
.button-ghost { background:transparent; color: #fff; border:1px solid rgba(255,255,255,0.08); padding:10px 12px; border-radius:10px; cursor:pointer; }
.back-link { color: #ffffff; text-decoration:none; display:inline-block; margin-bottom:12px; } /* белый цвет */
.title { outline: none; min-height:20px; color:#fff; font-weight:600; }
/* placeholder */
.title[contenteditable]:empty:before { content: attr(data-placeholder); color: rgba(255,255,255,0.35); display:block; }
</style>
</head>
<body>
  <div class="editor-page">
    <div class="canvas-area" id="canvasArea">
      <svg class="connector-svg" id="connectors" width="100%" height="100%"></svg>

      <!-- root node -->
      <div class="node" id="node-root" style="left:calc(50% - 130px); top:80px;" data-id="root">
        <div contenteditable class="title" data-placeholder="Опишите главный кадр...">Опишите главный кадр</div>
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div class="small-muted">Главный кадр</div>
          <div class="add-btn" title="Добавить исход">+</div>
        </div>
      </div>

    </div>

    <div class="side-panel">
      <a class="back-link" href="/">← Назад</a>
      <h3>ИИ-режиссёр (Поток кадров)</h3>
      <div class="small-muted">У каждого кадра допускается только один следующий кадр (один исход). Чтобы заменить исход — сначала удалите существующий у крестика на нём.</div>

      <div style="height:12px"></div>
      <div style="font-weight:600">Главный кадр</div>
      <div id="ai-title" class="small-muted"></div>

      <div style="height:10px"></div>
      <div style="font-weight:600">Исход (единственный)</div>
      <div id="ai-outcome" class="small-muted"></div>

      <div style="height:12px"></div>
      <div class="ai-box" id="ai-output">Нажмите «Предложить кадр», чтобы ИИ сгенерировал следующий кадр на основе заданного.</div>

      <div style="height:12px"></div>
      <div style="display:flex;gap:10px">
        <button class="button-primary" id="ai-run">Предложить кадр</button>
        <button class="button-ghost" id="ai-clear">Очистить все исходы</button>
      </div>
    </div>
  </div>

<script>
// Поток кадров: у каждого узла — максимум 1 исход
const canvas = document.getElementById('canvasArea');
const connectorsSvg = document.getElementById('connectors');
const edges = []; // {from, to}

// утилиты
function byId(id){ return document.querySelector(`[data-id="${id}"]`); }

// делаем элемент перетаскиваемым
function makeDraggable(elem) {
  let dragging=false, dx=0, dy=0;
  elem.addEventListener('mousedown', (e) => {
    // если клик по кнопке, не начинаем drag
    if (e.target.closest('.add-btn') || e.target.closest('.remove-btn')) return;
    dragging = true;
    const rect = elem.getBoundingClientRect();
    dx = e.clientX - rect.left;
    dy = e.clientY - rect.top;
    elem.style.zIndex = 1000;
  });
  document.addEventListener('mousemove', (e) => {
    if (!dragging) return;
    const rect = canvas.getBoundingClientRect();
    let nx = e.clientX - rect.left - dx;
    let ny = e.clientY - rect.top - dy;
    if (nx < 10) nx = 10;
    if (ny < 10) ny = 10;
    elem.style.left = nx + 'px';
    elem.style.top = ny + 'px';
    renderConnections();
  });
  document.addEventListener('mouseup', () => {
    if (dragging) {
      dragging = false;
      elem.style.zIndex = '';
    }
  });
}

// создание нового узла (child) с привязкой к parentId
function createNodeAt(x,y, text, parentId) {
  const id = 'node-' + Date.now() + '-' + Math.floor(Math.random()*1000);
  const div = document.createElement('div');
  div.className = 'node';
  div.style.left = x + 'px';
  div.style.top = y + 'px';
  div.dataset.id = id;
  div.innerHTML = `
    <div contenteditable class="title" data-placeholder="Опишите кадр...">${text}</div>
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div class="small-muted">Кадр</div>
      <div style="display:flex;gap:8px;align-items:center">
        <div class="add-btn" title="Добавить исход">+</div>
        <div class="remove-btn" title="Удалить узел">✕</div>
      </div>
    </div>
  `;
  canvas.appendChild(div);
  makeDraggable(div);
  setupNodeButtons(div);
  // связь parent->child
  if (parentId) {
    edges.push({from: parentId, to: id});
    // пометить parent что у него есть child
    const parent = byId(parentId);
    if (parent) {
      parent.dataset.childId = id;
      // отключаем кнопку добавления у parent
      const btn = parent.querySelector('.add-btn');
      if (btn) btn.setAttribute('disabled','');
    }
  }
  updateAIPreview();
  renderConnections();
  return id;
}

// удаление узла (и его ветки исходов рекурсивно)
function removeNode(nodeId) {
  const node = byId(nodeId);
  if (!node) return;
  // если у node есть child — рекурсивно удалить
  const childId = node.dataset.childId;
  if (childId) removeNode(childId);

  // удалить edge, и очистить parent.dataset.childId для родителя (если есть)
  const parentEdgeIndex = edges.findIndex(e => e.to === nodeId);
  if (parentEdgeIndex !== -1) {
    const parentId = edges[parentEdgeIndex].from;
    const parent = byId(parentId);
    if (parent) {
      delete parent.dataset.childId;
      const pbtn = parent.querySelector('.add-btn');
      if (pbtn) pbtn.removeAttribute('disabled');
    }
    edges.splice(parentEdgeIndex,1);
  }

  // удалить все edges where from == nodeId (т.е. его собственные исходы)
  for (let i = edges.length-1; i >= 0; i--) {
    if (edges[i].from === nodeId) edges.splice(i,1);
  }

  // удалить DOM
  node.remove();
  renderConnections();
  updateAIPreview();
}

// рендер связей (SVG кривые)
function renderConnections() {
  while (connectorsSvg.firstChild) connectorsSvg.removeChild(connectorsSvg.firstChild);
  edges.forEach(e => {
    const a = byId(e.from);
    const b = byId(e.to);
    if (!a || !b) return;
    const ra = a.getBoundingClientRect();
    const rb = b.getBoundingClientRect();
    const canvasRect = canvas.getBoundingClientRect();
    const x1 = ra.left + ra.width/2 - canvasRect.left;
    const y1 = ra.top + ra.height - canvasRect.top;
    const x2 = rb.left + rb.width/2 - canvasRect.left;
    const y2 = rb.top - canvasRect.top;
    const path = document.createElementNS('http://www.w3.org/2000/svg','path');
    const dx = Math.max(40, Math.abs(x2-x1)/2);
    const d = `M ${x1} ${y1} C ${x1} ${y1+dx} ${x2} ${y2-dx} ${x2} ${y2}`;
    path.setAttribute('d', d);
    path.setAttribute('stroke', 'rgba(255,255,255,0.12)');
    path.setAttribute('stroke-width', '2');
    path.setAttribute('fill', 'none');
    connectorsSvg.appendChild(path);
  });
}

// настраиваем кнопки добавления/удаления/редактирования у узла
function setupNodeButtons(nodeElem) {
  const addBtn = nodeElem.querySelector('.add-btn');
  const removeBtn = nodeElem.querySelector('.remove-btn');
  const titleEl = nodeElem.querySelector('.title');

  // если у узла уже есть child — отключаем кнопку
  if (nodeElem.dataset.childId) addBtn && addBtn.setAttribute('disabled','');
  else addBtn && addBtn.removeAttribute('disabled');

  if (addBtn) {
    addBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      // если уже есть исход — показываем подсказку (или можно заменить)
      if (nodeElem.dataset.childId) {
        // лёгкое визуальное уведомление: мигание
        addBtn.classList.add('blink');
        setTimeout(()=> addBtn.classList.remove('blink'), 350);
        return;
      }
      // создаём child рядом с parent
      const rect = nodeElem.getBoundingClientRect();
      const canvasRect = canvas.getBoundingClientRect();
      const x = rect.left - canvasRect.left + rect.width + 40;
      const y = rect.top - canvasRect.top;
      createNodeAt(x, y, 'Следующий кадр...', nodeElem.dataset.id);
    });
  }

  if (removeBtn) {
    removeBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      // при удалении узла — очистим связи корректно
      const id = nodeElem.dataset.id;
      removeNode(id);
    });
  }

  // обновление AI-превью при вводе
  titleEl && titleEl.addEventListener('input', updateAIPreview);
}

// инициализация существующих узлов (root)
document.querySelectorAll('.node').forEach(n => {
  makeDraggable(n);
  setupNodeButtons(n);
});

// вспомогательные: найти edge index по from->to
function findEdgeIndexFromTo(from, to) {
  return edges.findIndex(e => e.from === from && e.to === to);
}

// функция обновления панели ИИ (текущий заголовок и список исходов от корня)
function collectTreeForAI() {
  const root = byId('root');
  const seen = [];
  function traverse(id) {
    const node = byId(id);
    if (!node) return;
    const txt = node.querySelector('.title')?.innerText.trim() || '';
    seen.push({id, text: txt});
    const childId = node.dataset.childId;
    if (childId) traverse(childId);
  }
  traverse('root');
  return seen;
}

function updateAIPreview() {
  const tree = collectTreeForAI();
  const title = tree.length ? tree[0].text : '';
  const outcome = tree.length > 1 ? tree[1].text : '';
  document.getElementById('ai-title').innerText = title || '—';
  document.getElementById('ai-outcome').innerText = outcome || '—';
}

// кнопки панели
document.getElementById('ai-run').addEventListener('click', () => {
  const tree = collectTreeForAI();
  if (!tree.length || !tree[0].text) {
    document.getElementById('ai-output').innerText = 'Опишите главный кадр.';
    return;
  }
  const second = tree[1];
  if (!second || !second.text) {
    document.getElementById('ai-output').innerText = 'Добавьте хотя бы один исход (нажмите + у нужного кадра).';
    return;
  }
  // простая рекомендация ИИ
  const suggestion = `Предлагаемый следующий кадр: «${second.text}».\n\nПричина: этот кадр логично следует за главным кадром и прост в постановке.`;
  document.getElementById('ai-output').innerText = suggestion;
});

document.getElementById('ai-clear').addEventListener('click', () => {
  // удаляем все узлы кроме root
  const all = Array.from(document.querySelectorAll('.node')).map(n => n.dataset.id);
  for (const id of all) {
    if (id === 'root') continue;
    // removeNode безопасно рекурсивно удалит детей
    removeNode(id);
  }
  // очистим любые оставшиеся edges
  edges.length = 0;
  // сброс flags у root
  const root = byId('root');
  if (root) { delete root.dataset.childId; const btn = root.querySelector('.add-btn'); if (btn) btn.removeAttribute('disabled'); }
  renderConnections();
  updateAIPreview();
  document.getElementById('ai-output').innerText = 'Все исходы удалены.';
});

// следим за ресайзом/скроллом чтобы корректно перерисовывать линии
window.addEventListener('resize', renderConnections);
canvas.addEventListener('scroll', renderConnections);

// начальное обновление
updateAIPreview();
renderConnections();
</script>
</body>
</html>



